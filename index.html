<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Make it different</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Make it different">
<meta property="og:url" content="https://hackerman-ops.github.io/blog/index.html">
<meta property="og:site_name" content="Make it different">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="wuguobin">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/blog/atom.xml" title="Make it different" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/blog/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Make it different</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">stay hungry, stay foolish</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://hackerman-ops.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-django-架构总览图" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/24/django-%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88%E5%9B%BE/" class="article-date">
  <time datetime="2020-05-24T14:05:47.000Z" itemprop="datePublished">2020-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/24/django-%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88%E5%9B%BE/">django 架构总览图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="架构总览图"><a href="#架构总览图" class="headerlink" title="架构总览图"></a>架构总览图</h3><p>############################################################################################################</p>
<p><img src="2020/05/24/django-%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88%E5%9B%BE/django%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88.png" alt></p>
<h3 id="请求流程图"><a href="#请求流程图" class="headerlink" title="请求流程图"></a>请求流程图</h3><p>############################################################################################################</p>
<p><img src="djangohttp.png" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/24/django-%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88%E5%9B%BE/" data-id="ckammtq3y0005wui0e5i6bzwu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Django/" rel="tag">Django</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-django-启动过程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/24/django-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" class="article-date">
  <time datetime="2020-05-24T06:30:20.000Z" itemprop="datePublished">2020-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/24/django-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">django 启动过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/home/hacker/my_blog/source/_posts/django-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/django%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.png" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/24/django-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" data-id="ckammtq3x0004wui0dwge98wp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Django/" rel="tag">Django</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-redis-interview" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/23/redis-interview/" class="article-date">
  <time datetime="2020-05-23T07:00:16.000Z" itemprop="datePublished">2020-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/23/redis-interview/">redis interview</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="redis有哪些数据结构"><a href="#redis有哪些数据结构" class="headerlink" title="redis有哪些数据结构"></a>redis有哪些数据结构</h4><p>字符串String、字典Hash、列表List、集合Set、有序集合SortedSet，</p>
<p>下面几种数据结构HyperLogLog、Geo、Pub/Sub</p>
<p>Redis Module诸如像BloomFilter，RedisSearch，Redis-ML</p>
<h5 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h5><p>setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p>
<p>如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</p>
<p>set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的</p>
<h5 id="指定模式key列表"><a href="#指定模式key列表" class="headerlink" title="指定模式key列表"></a>指定模式key列表</h5><p>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</p>
<p>使用keys指令可以扫出指定模式的key列表。</p>
<p>如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p>
<p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
<h5 id="redis如何做异步队列"><a href="#redis如何做异步队列" class="headerlink" title="redis如何做异步队列"></a>redis如何做异步队列</h5><p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p>
<p>如果对方追问可不可以不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。</p>
<p>能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。</p>
<p>如果对方追问pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。</p>
<h5 id="redis如何做延时队列"><a href="#redis如何做延时队列" class="headerlink" title="redis如何做延时队列"></a>redis如何做延时队列</h5><p>使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。</p>
<h5 id="如果大量key同一时间过期"><a href="#如果大量key同一时间过期" class="headerlink" title="如果大量key同一时间过期"></a>如果大量key同一时间过期</h5><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p>
<h5 id="redis如何做持久化"><a href="#redis如何做持久化" class="headerlink" title="redis如何做持久化"></a>redis如何做持久化</h5><p>bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，优先使用aof来恢复内存的状态，如果没有aof日志，就会使用rdb文件来恢复。</p>
<p>如果再问aof文件过大恢复时间过长怎么办？你告诉面试官，Redis会定期做aof重写，压缩aof文件日志大小。如果面试官不够满意，再拿出杀手锏答案，Redis4.0之后有了混合持久化的功能，将bgsave的全量和aof的增量做了融合处理，这样既保证了恢复的效率又兼顾了数据的安全性。这个功能甚至很多面试官都不知道，他们肯定会对你刮目相看。</p>
<p>如果对方追问那如果突然机器掉电会怎样？取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。</p>
<p>如果对方追问bgsave的原理是什么？你给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p>
<h5 id="Pipeline有什么好处，为什么要用pipeline？"><a href="#Pipeline有什么好处，为什么要用pipeline？" class="headerlink" title="Pipeline有什么好处，为什么要用pipeline？"></a>Pipeline有什么好处，为什么要用pipeline？</h5><p>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p>
<h5 id="Redis的同步机制了解么？"><a href="#Redis的同步机制了解么？" class="headerlink" title="Redis的同步机制了解么？"></a>Redis的同步机制了解么？</h5><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p>
<h5 id="是否使用过Redis集群，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的原理是什么？"></a>是否使用过Redis集群，集群的原理是什么？</h5><p>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。</p>
<p>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/23/redis-interview/" data-id="ckammtq4h000zwui07ko8d3jx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/redis/" rel="tag">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-redis-API-test" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/22/redis-API-test/" class="article-date">
  <time datetime="2020-05-22T15:50:04.000Z" itemprop="datePublished">2020-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/22/redis-API-test/">redis API test</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="安利个人用redis监控软件"><a href="#安利个人用redis监控软件" class="headerlink" title="安利个人用redis监控软件"></a>安利个人用redis监控软件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull vieux&#x2F;redmon</span><br><span class="line">sudo docker run --net&#x3D;host -d  vieux&#x2F;redmon -r redis:&#x2F;&#x2F;127.0.0.1:6380</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/22/redis-API-test/" data-id="ckammtq4e000xwui03mzsadtv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/redis/" rel="tag">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-分布式锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/18/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="article-date">
  <time datetime="2020-05-18T12:27:51.000Z" itemprop="datePublished">2020-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/18/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">分布式锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="分布式锁的实现有哪些？"><a href="#分布式锁的实现有哪些？" class="headerlink" title="分布式锁的实现有哪些？"></a>分布式锁的实现有哪些？</h3><p><strong>1.Memcached分布式锁</strong></p>
<p>利用Memcached的<strong>add命令</strong>。此命令是原子性操作，只有在key不存在的情况下，才能add成功，也就意味着线程得到了锁。</p>
<p><strong>2.Redis分布式锁</strong></p>
<p>和Memcached的方式类似，利用Redis的<strong>setnx命令</strong>。此命令同样是原子性操作，只有在key不存在的情况下，才能set成功。（setnx命令并不完善，后续会介绍替代方案）</p>
<p><strong>3.Zookeeper分布式锁</strong></p>
<p>利用Zookeeper的<strong>顺序临时节点</strong>，来实现分布式锁和等待队列。Zookeeper设计的初衷，就是为了实现分布式锁服务的。</p>
<p><strong>4.Chubby</strong></p>
<p>Google公司实现的粗粒度分布式锁服务，底层利用了Paxos一致性算法。</p>
<h3 id="如何使用redis实现分布式锁"><a href="#如何使用redis实现分布式锁" class="headerlink" title="如何使用redis实现分布式锁"></a>如何使用redis实现分布式锁</h3><p><strong>1.加锁</strong></p>
<p>最简单的方法是使用setnx命令。key是锁的唯一标识，按业务来决定命名。比如想要给一种商品的秒杀活动加锁，可以给key命名为 “lock_sale_商品ID” 。而value设置成什么呢？我们可以姑且设置成1。加锁的伪代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx（key，1）</span><br></pre></td></tr></table></figure>



<p>当一个线程执行setnx返回1，说明key原本不存在，该线程成功得到了锁；当一个线程执行setnx返回0，说明key已经存在，该线程抢锁失败。</p>
<p><strong>2.解锁</strong></p>
<p>有加锁就得有解锁。当得到锁的线程执行完任务，需要释放锁，以便其他线程可以进入。释放锁的最简单方式是执行del指令，伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del（key）</span><br></pre></td></tr></table></figure>

<p>释放锁之后，其他线程就可以继续执行setnx命令来获得锁。</p>
<p><strong>3.锁超时</strong></p>
<p>如果一个得到锁的线程在执行任务的过程中挂掉，来不及显式地释放锁，这块资源将会永远被锁住，别的线程再也别想进来。</p>
<p>所以，setnx的key必须设置一个超时时间，以保证即使没有被显式释放，这把锁也要在一定时间后自动释放。setnx不支持超时参数，所以需要额外的指令，伪代码如下：</p>
<p><strong>expire（key， 30）</strong></p>
<p>综合起来，我们分布式锁实现的第一版伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if（setnx（key，1） &#x3D;&#x3D; 1）&#123;</span><br><span class="line"></span><br><span class="line">  expire（key，30）</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line"></span><br><span class="line">   *\*do something ......\</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">   *\*del（key）\**</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>告警 BUG</strong></p>
<p>#######################################################################</p>
<h4 id="1-setnx和expire的非原子性"><a href="#1-setnx和expire的非原子性" class="headerlink" title="1 setnx和expire的非原子性"></a>1 setnx和expire的非原子性</h4><p>当某线程执行setnx，成功得到了锁：setnx刚执行成功，还未来得及执行expire指令，节点1 Duang的一声挂掉了。幸好Redis 2.6.12以上版本为<strong>set</strong>指令增加了可选参数，伪代码如下：</p>
<p><strong>set（key，1，30，NX）</strong></p>
<p>这样就可以取代setnx指令。</p>
<p>########################################################################</p>
<h4 id="2-del-误删"><a href="#2-del-误删" class="headerlink" title="2 del 误删"></a>2 del 误删</h4><p>假如某线程A成功得到了锁，并且设置的超时时间是30秒。</p>
<p>如果某些原因导致线程A执行的很慢很慢，过了30秒都没执行完，这时候锁过期自动释放，线程B得到了锁。</p>
<p>随后，线程A执行完了任务，线程A接着执行del指令来释放锁。但这时候线程B还没执行完，<strong>线程A实际上删除的是线程B加的锁</strong>。</p>
<p>怎么避免这种情况呢？可以在del释放锁之前做一个判断，验证当前的锁是不是自己加的锁。</p>
<p>至于具体的实现，可以在加锁的时候把当前的线程ID当做value，并在删除之前验证key对应的value是不是自己线程的ID。</p>
<p>加锁：</p>
<p><strong>String threadId = Thread.currentThread().getId()</strong></p>
<p>set（key，threadId，30，NX）</p>
<p>解锁：</p>
<p><strong>if（**</strong>threadId** <strong>.equals(redisClient.get(\</strong>key**))）{</p>
<p>  del(key)</p>
<p><strong>}</strong></p>
<p>但是，这样做又隐含了一个新的问题，<strong>判断和释放锁是两个独立操作，不是原子性</strong>。</p>
<p>原子执行即可</p>
<p>#########################################################################</p>
<h4 id="出现并发可能性"><a href="#出现并发可能性" class="headerlink" title="出现并发可能性"></a>出现并发可能性</h4><p>我们避免了线程A误删掉key的情况，但是同一时间有A，B两个线程在访问代码块，仍然是不完美的。</p>
<p>线程好长时间没执行完，需要给锁续命</p>
<p>我们可以让获得锁的线程开启一个<strong>守护线程</strong>，用来给快要过期的锁“续航”。</p>
<p>当过去了29秒，线程A还没执行完，这时候守护线程会执行expire指令，为这把锁“续命”20秒。守护线程从第29秒开始执行，每20秒执行一次。</p>
<p>当线程A执行完任务，会显式关掉守护线程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/18/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" data-id="ckammtq4l0016wui00ydvg1pz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-django-安全编码问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/17/django-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-05-17T14:57:16.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/17/django-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/">django 安全编码问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从浏览器传过来的任何性质的数据，都需要近乎狂热地接受检查。 这包括用户数据（比如Web表单提交的内容）和带外数据（比如，HTTP头、cookies以及其他信息）。 要修改那些浏览器自动添加的元数据，是一件很容易的事。</p>
<h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>在SQL注入中，攻击者改变web网页的参数（例如 <code>GET</code> /<code>POST</code> 数据或者URL地址），加入一些其他的SQL片段。 未加处理的网站会将这些信息在后台数据库直接运行。</p>
<p>绝不信任用户提交的数据，并且在传递给SQL语句时，总是转义它。</p>
<p>quato_name 函数</p>
<h3 id="跨站点脚本-XSS"><a href="#跨站点脚本-XSS" class="headerlink" title="跨站点脚本 (XSS)"></a>跨站点脚本 (XSS)</h3><p><em>跨站点脚本</em> (XSS)有时在被渲染成HTML之前，不能恰当地对用户提交的内容进行转义。 这使得攻击者能够向你的网站页面插入通常以 `` 标签形式的任意HTML代码。</p>
<p>总是转义可能来自某个用户的任何内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from django.shortcuts import render_to_response</span><br><span class="line"></span><br><span class="line">def say_hello(request):</span><br><span class="line">    name &#x3D; request.GET.get(&#39;name&#39;, &#39;world&#39;)</span><br><span class="line">    return render_to_response(&#39;hello.html&#39;, &#123;&#39;name&#39;: name&#125;)</span><br><span class="line"></span><br><span class="line"># hello.html</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;Hello, &lt;i&gt;Jacob&lt;&#x2F;i&gt;!&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>

<h3 id="伪造跨站点请求"><a href="#伪造跨站点请求" class="headerlink" title="伪造跨站点请求"></a>伪造跨站点请求</h3><p>伪造跨站点请求(CSRF)发生在当某个恶意Web站点诱骗用户不知不觉的从一个信任站点下载某个URL之时，这个信任站点已经被通过信任验证，因此恶意站点就利用了这个被信任状态。</p>
<p>Django拥有内建工具来防止这种攻击</p>
<h4 id="使用CSRF中间件"><a href="#使用CSRF中间件" class="headerlink" title="使用CSRF中间件"></a>使用CSRF中间件</h4><p><code>django.contrib.csrf</code> 开发包只有一个模块： <code>middleware.py</code> 。该模块包含了一个 Django 中间件类—— <code>CsrfMiddleware</code> ，该类实现了 CSRF 防护功能。</p>
<p>在设置文件中将 <code>&#39;django.contrib.csrf.middleware.CsrfMiddleware&#39;</code> 添加到 <code>MIDDLEWARE_CLASSES</code> 设置中可激活 CSRF 防护。 该中间件必须在 <code>SessionMiddleware</code> <em>之后</em> 执行，因此在列表中 <code>CsrfMiddleware</code> 必须出现在 <code>SessionMiddleware</code> <em>之前</em> （因为响应中间件是自后向前执行的）。 同时，它也必须在响应被压缩或解压之前对响应结果进行处理，因此 <code>CsrfMiddleware</code> 必须在 <code>GZipMiddleware</code> 之后执行。一旦将它添加到<code>MIDDLEWARE_CLASSES</code>设置中，你就完成了工作。 </p>
<p>下面是 <code>CsrfMiddleware</code> 的工作模式。 它完成以下两项工作：</p>
<ol>
<li>它修改当前处理的请求，向所有的 <code>POST</code> 表单增添一个隐藏的表单字段，使用名称是 <code>csrfmiddlewaretoken</code> ，值为当前会话 ID 加上一个密钥的散列值。 如果未设置会话 ID ，该中间件将 <em>不会</em> 修改响应结果，因此对于未使用会话的请求来说性能损失是可以忽略的。</li>
</ol>
<ol>
<li>对于所有含会话 cookie 集合的传入 <code>POST</code> 请求，它将检查是否存在 <code>csrfmiddlewaretoken</code> 及其是否正确。 如果不是的话，用户将会收到一个 403 <code>HTTP</code> 错误。 403 错误页面的内容是检测到了跨域请求伪装。 终止请求。</li>
</ol>
<p>该步骤确保只有源自你的站点的表单才能将数据 POST 回来。</p>
<p>该中间件特意只针对 HTTP <code>POST</code> 请求（以及对应的 POST 表单）。 如我们所解释的，永远不应该因为使用了 <code>GET</code> 请求而产生负面效应，你必须自己来确保这一点。</p>
<p>未使用会话 cookie 的 <code>POST</code> 请求无法受到保护，但它们也不 <em>需要</em> 受到保护，因为恶意网站可用任意方法来制造这种请求。</p>
<p>为了避免转换非 HTML 请求，中间件在编辑响应结果之前对它的 <code>Content-Type</code> 头标进行检查。 只有标记为 <code>text/html</code> 或 <code>application/xml+xhtml</code> 的页面才会被修改。</p>
<h3 id="会话伪造-劫持"><a href="#会话伪造-劫持" class="headerlink" title="会话伪造/劫持"></a>会话伪造/劫持</h3><p>对用户会话数据的通用类攻击。 这种攻击可以采取多种形式：</p>
<p><em>中间人</em> 攻击：检索所在有线（无线）网络，监听会话数据。</p>
<p><em>伪造会话</em> ：攻击者利用会话ID（可能是通过中间人攻击来获得）将自己伪装成另一个用户。</p>
<p>这两种攻击的一个例子可以是在一间咖啡店里的某个攻击者利用店内的无线网络来捕获某个会话cookie，然后她就可以利用那个cookie来假冒原始用户。 她便可以使该cookie来模拟原始用户。</p>
<p><em>伪造cookie</em> ：就是指某个攻击者覆盖了在某个cookie中本应该是只读的数据。 <code>第十四章 &lt;../chapter14/&gt;</code>__ 详细介绍了cookies如何工作，以及要点之一的是，它在你不知道的情况下无视浏览器和恶意用户私自改变cookies。</p>
<p>Web站点以 <code>IsLoggedIn=1</code> 或者 <code>LoggedInAsUser=jacob</code> 这样的方式来保存cookie由来已久，使用这样的cookie是再简单不过的了。</p>
<p>一个更微妙的层面上，然而，相信在cookies中存储的任意信息绝对不是一个好主意。 你永远不知道谁一直在作怪。</p>
<p><em>会话滞留</em> ：攻击者诱骗用户设置或者重设置该用户的会话ID。</p>
<p>例如，PHP允许在URL（如 <code>http://example.com/?PHPSESSID=fa90197ca25f6ab40bb1374c510d7a32</code> 等）中传递会话标识符。攻击者欺骗用户点击一个硬编码会话ID的链接，这回导致用户转到那个会话。</p>
<p>会话滞留已经运用在钓鱼攻击中，以诱骗用户在攻击者拥有的账号里输入其个人信息。 他可以稍后登陆账户并且检索数据。</p>
<p><em>会话中毒</em> ：攻击者通过用户提交设置会话数据的Web表单向该用户会话中注入潜在危险数据。</p>
<p>一个经典的例子就是一个站点在某个cookie中存储了简单的用户偏好（比如一个页面背景颜色）。 攻击者可以诱骗用户点击一个链接来提交背景颜色，实际上包含了一个XSS攻击。 如果颜色没有转义，那么就可以再把恶意代码注入到用户环境中。</p>
<p><strong>解决方案：</strong></p>
<p>不要在URL中包含任何session信息。</p>
<p>Django的session框架（参见<code>第十四章 &lt;../chapter14/&gt;</code>__ ）根本不会容许session包含在URL中。</p>
<p>不要直接在cookie中保存数据。 相反，存储一个在后台映射到session数据存储的session ID。</p>
<p>如果使用Django内置的session框架（即 <code>request.session</code> ），它会自动进行处理。 这个session框架仅在cookie中存储一个session ID，所有的session数据将会被存储在数据库中。</p>
<p>如果需要在模板中显示session数据，要记得对其进行转义。 可参考之前的XSS部分，对所有用户提交的数据和浏览器提交的数据进行转义。 对于session信息，应该像用户提交的数据一样对其进行处理。</p>
<p>任何可能的地方都要防止攻击者进行session欺骗。</p>
<p>尽管去探测究竟是谁劫持了会话ID是几乎不可能的事儿，Django还是内置了保护措施来抵御暴力会话攻击。 会话ID被存在哈希表里（取代了序列数字），这样就阻止了暴力攻击，并且如果一个用户去尝试一个不存在的会话那么她总是会得到一个新的会话ID，这样就阻止了会话滞留。</p>
<p>请注意，以上没有一种准则和工具能够阻止中间人攻击。 这些类型的攻击是几乎不可能被探测的。 如果你的站点允许登陆用户去查看任意敏感数据的话，你应该 <em>总是</em> 通过HTTPS来提供网站服务。 此外，如果你的站点使用SSL，你应该将 <code>SESSION_COOKIE_SECURE</code> 设置为 <code>True</code> ，这样就能够使Django只通过HTTPS发送会话cookie。</p>
<h3 id="邮件头部注入"><a href="#邮件头部注入" class="headerlink" title="邮件头部注入"></a>邮件头部注入</h3><p><em>邮件头部注入</em> ：SQL注入的兄弟，是一种通过劫持发送邮件的Web表单的攻击方式。 攻击者能够利用这种技术来通过你的邮件服务器发送垃圾邮件。 在这种攻击面前，任何方式的来自Web表单数据的邮件头部构筑都是非常脆弱的。</p>
<p>让我们看看在我们许多网站中发现的这种攻击的形式。 通常这种攻击会向硬编码邮件地址发送一个消息，因此，第一眼看上去并不显得像面对垃圾邮件那么脆弱。</p>
<p>但是，大多数表单都允许用户输入自己的邮件主题（同时还有from地址，邮件体，有时还有部分其他字段）。 这个主题字段被用来构建邮件消息的主题头部。</p>
<p>如果那个邮件头部在构建邮件信息时没有被转义，那么攻击者可以提交类似 <code>&quot;hello\ncc:spamvictim@example.com&quot;</code> （这里的 <code>&quot;\n&quot;</code> 是换行符）的东西。 这有可能使得所构建的邮件头部变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">To: hardcoded@example.com</span><br><span class="line">Subject: hello</span><br><span class="line">cc: spamvictim@example.com</span><br></pre></td></tr></table></figure>

<p>就像SQL注入那样，如果我们信任了用户提供的主题行，那样同样也会允许他构建一个头部恶意集，他也就能够利用联系人表单来发送垃圾邮件。</p>
<p><strong>解决方案</strong></p>
<p>我们能够采用与阻止SQL注入相同的方式来阻止这种攻击： 总是校验或者转义用户提交的内容。</p>
<p>Django内建邮件功能（在 <code>django.core.mail</code> 中）根本不允许在用来构建邮件头部的字段中存在换行符（表单，收件地址，还有主题）。 如果您试图使用 <code>django.core.mail.send_mail</code> 来处理包含换行符的主题时，Django将会抛出BadHeaderError异常。</p>
<p>如果你没有使用Django内建邮件功能来发送邮件，那么你需要确保包含在邮件头部的换行符能够引发错误或者被去掉。 你或许想仔细阅读 <code>django.core.mail</code> 中的 <code>SateMIMEText</code> 类来看看Django是如何做到这一点的。</p>
<h3 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h3><p><em>目录遍历</em> ：是另外一种注入方式的攻击，在这种攻击中，恶意用户诱骗文件系统代码对Web服务器不应该访问的文件进行读取和/或写入操作。</p>
<p>例子可以是这样的，某个视图试图在没有仔细对文件进行防毒处理的情况下从磁盘上读取文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def dump_file(request):</span><br><span class="line">    filename &#x3D; request.GET[&quot;filename&quot;]</span><br><span class="line">    filename &#x3D; os.path.join(BASE_PATH, filename)</span><br><span class="line">    content &#x3D; open(filename).read()</span><br><span class="line"></span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>尽管一眼看上去，视图通过 <code>BASE_PATH</code> （通过使用 <code>os.path.join</code> ）限制了对于文件的访问，但如果攻击者使用了包含 <code>..</code> （两个句号，父目录的一种简写形式）的文件名，她就能够访问到 <code>BASE_PATH</code> 目录结构以上的文件。对她来说，发现究竟使用几个点号只是时间问题，比如这样：<code>../../../../../etc/passwd</code>。</p>
<p>任何不做适当转义地读取文件操作，都可能导致这样的问题。 允许 <em>写</em> 操作的视图同样容易发生问题，而且结果往往更加可怕。</p>
<p>这个问题的另一种表现形式，出现在根据URL和其他的请求信息动态地加载模块。 一个众所周知的例子来自于Ruby on Rails。 在2006年上半年之前，Rails使用类似于 <code>http://example.com/person/poke/1</code> 这样的URL直接加载模块和调用函数。 结果是，精心构造的URL，可以自动地调用任意的代码，包括数据库的清空脚本。</p>
<p><strong>解决方案</strong></p>
<p>如果你的代码需要根据用户的输入来读写文件，你就需要确保，攻击者不能访问你所禁止访问的目录。</p>
<h3 id="暴露错误消息"><a href="#暴露错误消息" class="headerlink" title="暴露错误消息"></a>暴露错误消息</h3><p>在开发过程中，通过浏览器检查错误和跟踪异常是非常有用的。 Django提供了漂亮且详细的debug信息，使得调试过程更加容易。</p>
<p>然而，一旦在站点上线以后，这些消息仍然被显示，它们就可能暴露你的代码或者是配置文件内容给攻击者。</p>
<p>还有，错误和调试消息对于最终用户而言是毫无用处的。 Django的理念是，站点的访问者永远不应该看到与应用相关的出错消息。 如果你的代码抛出了一个没有处理的异常，网站访问者不应该看到调试信息或者 <em>任何</em> 代码片段或者Python（面向开发者）出错消息。 访问者应该只看到友好的无法访问的页面。</p>
<p>当然，开发者需要在debug时看到调试信息。 因此，框架就要将这些出错消息显示给受信任的网站开发者，而要向公众隐藏。</p>
<p><strong>解决方案</strong></p>
<p>正如我们在第12章所提到的，Django的<code>DEBUG</code> 设置控制这些错误信息的显示。 当你准备部署时请确认把这个设置为：<code>False</code> 。</p>
<p>在Apache和mod_python下开发的人员，还要保证在Apache的配置文件中关闭 <code>PythonDebug Off</code> 选项，这个会在Django被加载以前去除出错消息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/17/django-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/" data-id="ckammtq53001swui049ln1lvk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-django-sql注入" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/17/django-sql%E6%B3%A8%E5%85%A5/" class="article-date">
  <time datetime="2020-05-17T13:26:03.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/17/django-sql%E6%B3%A8%E5%85%A5/">django sql注入</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令</p>
<p>利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句</p>
<ol>
<li><p>永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双’-‘进行转换等。</p>
</li>
<li><p>永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。</p>
</li>
<li><p>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</p>
</li>
<li><p>不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。</p>
</li>
<li><p>应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装。</p>
</li>
</ol>
<p><strong>利用Dajngo的ORM可有效避免sql注入，因为Django已经对特殊字符进行转义</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/17/django-sql%E6%B3%A8%E5%85%A5/" data-id="ckammtq3v0003wui03yhw5kg1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-如何设计良好API" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/17/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E8%89%AF%E5%A5%BDAPI/" class="article-date">
  <time datetime="2020-05-17T12:44:13.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/17/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E8%89%AF%E5%A5%BDAPI/">如何设计良好API</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="职责清晰"><a href="#职责清晰" class="headerlink" title="职责清晰"></a>职责清晰</h3><p>API 必须指明接口类型，接口职责，具体解决什么业务</p>
<h3 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h3><p>职责清晰之后，尽量做到接口职责单一</p>
<h3 id="协议规范"><a href="#协议规范" class="headerlink" title="协议规范"></a>协议规范</h3><p>明确接口协议，http，https，ftp等等，或者其他rpc协议</p>
<h3 id="路径规则，合理命名"><a href="#路径规则，合理命名" class="headerlink" title="路径规则，合理命名"></a>路径规则，合理命名</h3><p>网址尽量用名词而不是动词</p>
<p>/api/v1.0/Pruduct/2020</p>
<p>/api/v1.0/Users/2020</p>
<p>其次，命名需要注意这些：</p>
<ul>
<li>尽可能和领域名词保持一致，例如聚合根、实体、事件等</li>
<li>RESTful 设计的 URI 中使用名词复数</li>
<li>尽可能不要过度简写，例如将 <code>user</code> 简写成 <code>usr</code></li>
<li>尽可能使用不需要编码的字符</li>
</ul>
<h3 id="http请求方式"><a href="#http请求方式" class="headerlink" title="http请求方式"></a>http请求方式</h3><p>restful </p>
<p>接口基本访问协议：get(获取)，post(新增)，put(修改)和delete(删除)</p>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>域名分为主域名和专有域名，主域名适合api长期不变或变化较少的业务，专有域名是解决具体的专有业务的</p>
<h3 id="跨域考虑"><a href="#跨域考虑" class="headerlink" title="跨域考虑"></a>跨域考虑</h3><p>在明确域名的情况下，一定要考虑接口是否跨域，以及跨域应采用的技术手段等</p>
<h3 id="版本设计"><a href="#版本设计" class="headerlink" title="版本设计"></a>版本设计</h3><p>对于接口的url，应加版本号<a href="http://api.demo.com/v{d}/，如" target="_blank" rel="noopener">http://api.demo.com/v{d}/，如</a> ，其中d表示版本号,如v1.0,v2.0</p>
<p>例子：获取产品号为2019,版本号为v1.0的版本号的产品信息</p>
<h3 id="适度过滤信息"><a href="#适度过滤信息" class="headerlink" title="适度过滤信息"></a>适度过滤信息</h3><p>当记录数比较多时(如 SELECT * FROM TBName)，因适当添加一些条件对数据进行过滤，如TOP,分页,分组，排序和WHERE条件等</p>
<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>返回数据格式，一般包括三个字段：</p>
<p>(1) 失败情况（状态码、错误码和错误描述）</p>
<p>(2) 成功情况（标识id,数据对象,状态码）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;id&quot;: &quot;dsafrgrg&quot;,</span><br><span class="line">&quot;users&quot;: &#123;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">&quot;status&quot;:1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安全性原则"><a href="#安全性原则" class="headerlink" title="安全性原则"></a>安全性原则</h3><p>接口暴露的考虑，接口并发量的考虑，接口防攻击的考虑，接口跨域的考虑等。</p>
<p>针对错误的调用方式，API 不应该进入业务处理流程，及时给出错误信息；对于接口滥用的情况，需要做一些限速的方案；对于一些浏览器消费者的问题，可以在让 API 返回一些安全增强头部，例如：X-XSS-Protection、Content-Security-Policy 等。</p>
<h3 id="接口可扩展"><a href="#接口可扩展" class="headerlink" title="接口可扩展"></a>接口可扩展</h3><p>在设计接口时，充分考虑接口的可扩展性。</p>
<h3 id="API-权限"><a href="#API-权限" class="headerlink" title="API 权限"></a>API 权限</h3><p>任何api，从权限上，可归结为匿名api和非匿名api，前者不需要验证，后者需要验证。</p>
<h3 id="定义api返回码"><a href="#定义api返回码" class="headerlink" title="定义api返回码"></a>定义api返回码</h3><p>在api设计时，要定好api返回码，如：</p>
<p>1 –授权过期</p>
<p>404–未找到资源</p>
<p>500–内部服务器错误</p>
<p>600–账号被锁</p>
<h3 id="API-设计评审清单"><a href="#API-设计评审清单" class="headerlink" title="API 设计评审清单"></a>API 设计评审清单</h3><ul>
<li>URI 命名是否通过聚合根和实体统一</li>
<li>URI 命名是否采用名词复数和连接线</li>
<li>URI 命名是否都是单词小写</li>
<li>URI 是否暴露了不必要的信息，例如 <code>/cgi-bin</code></li>
<li>URI 规则是否统一</li>
<li>资源提供的能力是否彼此独立</li>
<li>URI 是否存在需要编码的字符</li>
<li>请求和返回的参数是否不多不少</li>
<li>资源的 ID 参数是否通过 PATH 参数传递</li>
<li>认证和授权信息是否暴露到 query 参数中</li>
<li>参数是否使用奇怪的缩写</li>
<li>参数和响应数据中的字段命名统一</li>
<li>是否存在无意义的对象包装 例如 <code>{&quot;data&quot;:{}&#39;}</code></li>
<li>出错时是否破坏约定的数据结构</li>
<li>是否使用合适的状态码</li>
<li>是否使用合适的媒体类型</li>
<li>响应数据的单复是否和数据内容一致</li>
<li>响应头中是否有缓存信息</li>
<li>是否进行了版本管理</li>
<li>版本信息是否作为 URI 的前缀存在</li>
<li>是否提供 API 服务期限</li>
<li>是否提供了 API 返回所有 API 的索引</li>
<li>是否进行了认证和授权</li>
<li>是否采用 HTTPS</li>
<li>是否检查了非法参数</li>
<li>是否增加安全性的头部</li>
<li>是否有限流策略</li>
<li>是否支持 CORS</li>
<li>响应中的时间格式是否采用 <code>ISO 8601</code> 标准</li>
<li>是否存在越权访问</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/17/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E8%89%AF%E5%A5%BDAPI/" data-id="ckammtq4m0018wui0fa3p5iwz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/web/" rel="tag">web</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python-interview" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/17/python-interview/" class="article-date">
  <time datetime="2020-05-17T04:26:13.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/17/python-interview/">python interview</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/17/python-interview/" data-id="ckammtq4c000swui0b1hjac0n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-faust-demo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/16/faust-demo/" class="article-date">
  <time datetime="2020-05-16T14:38:21.000Z" itemprop="datePublished">2020-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/16/faust-demo/">faust demo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/16/faust-demo/" data-id="ckammtq3z0008wui01wftgjjf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/python-kafka/" rel="tag">python kafka</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="page-number" href="/blog/page/3/">3</a><a class="extend next" rel="next" href="/blog/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Django/" rel="tag">Django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/kafka/" rel="tag">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/process/" rel="tag">process</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/python-kafka/" rel="tag">python kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/web/" rel="tag">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/Django/" style="font-size: 16.67px;">Django</a> <a href="/blog/tags/kafka/" style="font-size: 10px;">kafka</a> <a href="/blog/tags/linux/" style="font-size: 16.67px;">linux</a> <a href="/blog/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/blog/tags/process/" style="font-size: 10px;">process</a> <a href="/blog/tags/python/" style="font-size: 20px;">python</a> <a href="/blog/tags/python-kafka/" style="font-size: 10px;">python kafka</a> <a href="/blog/tags/redis/" style="font-size: 16.67px;">redis</a> <a href="/blog/tags/web/" style="font-size: 10px;">web</a> <a href="/blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 16.67px;">中间件</a> <a href="/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.33px;">数据结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2020/05/24/django-%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88%E5%9B%BE/">django 架构总览图</a>
          </li>
        
          <li>
            <a href="/blog/2020/05/24/django-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">django 启动过程</a>
          </li>
        
          <li>
            <a href="/blog/2020/05/23/redis-interview/">redis interview</a>
          </li>
        
          <li>
            <a href="/blog/2020/05/22/redis-API-test/">redis API test</a>
          </li>
        
          <li>
            <a href="/blog/2020/05/18/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">分布式锁</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 wuguobin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">

  
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>




<script src="/blog/js/script.js"></script>




  </div>
</body>
</html>