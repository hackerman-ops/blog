<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Make it different</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Make it different">
<meta property="og:url" content="https://hackerman-ops.github.io/blog/index.html">
<meta property="og:site_name" content="Make it different">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="wuguobin">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/blog/atom.xml" title="Make it different" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/blog/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Make it different</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">stay hungry, stay foolish</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://hackerman-ops.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-kafka-base" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/16/kafka-base/" class="article-date">
  <time datetime="2020-05-16T12:50:44.000Z" itemprop="datePublished">2020-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/16/kafka-base/">kafka base</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>前言</p>
</li>
<li><p>一、Kafka基础</p>
</li>
<li><ul>
<li>消息系统的作用</li>
<li>1.Topic 主题</li>
<li>2.Partition 分区</li>
<li>3.Producer - 生产者</li>
<li>4.Consumer - 消费者</li>
<li>5.Message - 消息</li>
</ul>
</li>
<li><p>二、kafka的集群架构</p>
</li>
<li><ul>
<li>Replica - 副本</li>
<li>Consumer Group - 消费者组</li>
<li>Controller</li>
<li>kafka和zookeeper如何配合工作</li>
</ul>
</li>
<li><p>加餐时间</p>
</li>
<li><ul>
<li>1.Kafka性能好在什么地方？</li>
<li>2.日志分段存储</li>
<li>3.Kafka的网络设计</li>
<li></li>
</ul>
</li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>应大部分的小伙伴的要求，在Yarn之前先来一个kafka的小插曲，轻松愉快。</p>
<h2 id="一、Kafka基础"><a href="#一、Kafka基础" class="headerlink" title="一、Kafka基础"></a>一、Kafka基础</h2><h2 id="消息系统的作用"><a href="#消息系统的作用" class="headerlink" title="消息系统的作用"></a>消息系统的作用</h2><p>引入一个场景，我们知道中国移动，中国联通，中国电信的日志处理，是交给外包去做大数据分析的，假设现在它们的日志都交给了你做的系统去做用户画像分析。</p>
<p><img src="2020/05/16/kafka-base/kafka1.png" alt="img"></p>
<p>按照刚刚前面提到的消息系统的作用，我们知道了消息系统其实就是一个<strong>模拟缓存</strong> ，且<strong>仅仅是起到了缓存的作用</strong> 而并不是真正的缓存，数据仍然是存储在磁盘上面而不是内存。</p>
<h2 id="1-Topic-主题"><a href="#1-Topic-主题" class="headerlink" title="1.Topic 主题"></a>1.Topic 主题</h2><p>kafka学习了数据库里面的设计，在里面设计了topic（主题），这个东西类似于关系型数据库的表</p>
<p><img src="https://pic2.zhimg.com/80/v2-32846cde6385e104150543c2bd33e255_720w.jpg" alt="img"></p>
<p>此时我需要获取中国移动的数据，那就直接监听TopicA即可</p>
<h2 id="2-Partition-分区"><a href="#2-Partition-分区" class="headerlink" title="2.Partition 分区"></a>2.Partition 分区</h2><p>kafka还有一个概念叫Partition（分区），分区具体在服务器上面表现起初就是一个目录，一个主题下面有多个分区，这些分区会存储到不同的服务器上面，或者说，其实就是在不同的主机上建了不同的目录。这些分区主要的信息就存在了.log文件里面。跟数据库里面的分区差不多，是为了提高性能。</p>
<p><img src="https://pic4.zhimg.com/80/v2-af7ed1fd8fb43ea93baa9d2db2c4e5c3_720w.jpg" alt="img"></p>
<p>至于为什么提高了性能，很简单，多个分区多个线程，多个线程并行处理肯定会比单线程好得多</p>
<p>Topic和partition像是HBASE里的table和region的概念，table只是一个逻辑上的概念，真正存储数据的是region，这些region会分布式地存储在各个服务器上面，对应于kafka，也是一样，<strong>Topic也是逻辑概念</strong> ，而partition就是分布式存储单元。这个设计是保证了海量数据处理的基础。我们可以对比一下，如果HDFS没有block的设计，一个100T的文件也只能单独放在一个服务器上面，那就直接占满整个服务器了，引入block后，大文件可以分散存储在不同的服务器上。</p>
<p>注意：1.分区会有单点故障问题，所以我们会为每个分区设置副本数</p>
<p>2.分区的编号是从0开始的</p>
<h2 id="3-Producer-生产者"><a href="#3-Producer-生产者" class="headerlink" title="3.Producer - 生产者"></a>3.Producer - 生产者</h2><p>往消息系统里面发送数据的就是生产者</p>
<p><img src="https://pic4.zhimg.com/80/v2-3acb2d8ff2a4672d66ed93f23dfe222b_720w.jpg" alt="img"></p>
<h2 id="4-Consumer-消费者"><a href="#4-Consumer-消费者" class="headerlink" title="4.Consumer - 消费者"></a>4.Consumer - 消费者</h2><p>从kafka里读取数据的就是消费者</p>
<p><img src="https://pic3.zhimg.com/80/v2-18604049cbfc5da50c33ea20b241456e_720w.jpg" alt="img"></p>
<h2 id="5-Message-消息"><a href="#5-Message-消息" class="headerlink" title="5.Message - 消息"></a>5.Message - 消息</h2><p>kafka里面的我们处理的数据叫做消息</p>
<h2 id="二、kafka的集群架构"><a href="#二、kafka的集群架构" class="headerlink" title="二、kafka的集群架构"></a>二、kafka的集群架构</h2><p>创建一个TopicA的主题，3个分区分别存储在不同的服务器，也就是broker下面。<strong>Topic是一个逻辑上的概念</strong> ，并不能直接在图中把Topic的相关单元画出</p>
<p><img src="https://pic2.zhimg.com/80/v2-34ac636c297dd20ec43e992bdf034d01_720w.jpg" alt="img"></p>
<p><strong>需要注意：kafka在0.8版本以前是没有副本机制的，所以在面对服务器宕机的突发情况时会丢失数据，所以尽量避免使用这个版本之前的kafka</strong></p>
<h2 id="Replica-副本"><a href="#Replica-副本" class="headerlink" title="Replica - 副本"></a>Replica - 副本</h2><p>kafka中的partition为了保证数据安全，所以每个partition可以设置多个副本。</p>
<p>此时我们对分区0,1,2分别设置3个副本（其实设置两个副本是比较合适的）</p>
<p><img src="https://pic3.zhimg.com/80/v2-98e71e20de54e547a02a9fd38360ec16_720w.jpg" alt="img"></p>
<p>而且其实每个副本都是有角色之分的，它们会选取一个副本作为leader，而其余的作为follower，我们的<strong>生产者在发送数据的时候，是直接发送到leader partition里面</strong> ，然后follower partition会去leader那里自行同步数据，<strong>消费者消费数据的时候，也是从leader那去消费数据的</strong> 。</p>
<p><img src="https://pic1.zhimg.com/80/v2-25f67642f98939529165464e08d8c334_720w.jpg" alt="img"></p>
<h2 id="Consumer-Group-消费者组"><a href="#Consumer-Group-消费者组" class="headerlink" title="Consumer Group - 消费者组"></a>Consumer Group - 消费者组</h2><p>我们在消费数据时会在代码里面指定一个group.id,这个id代表的是消费组的名字，而且<strong>这个group.id就算不设置，系统也会默认设置</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conf.setProperty(&quot;group.id&quot;,&quot;tellYourDream&quot;)</span><br></pre></td></tr></table></figure>

<p>我们所熟知的一些消息系统一般来说会这样设计，就是只要有一个消费者去消费了消息系统里面的数据，那么其余所有的消费者都不能再去消费这个数据。可是kafka并不是这样,比如现在consumerA去消费了一个topicA里面的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumerA:    group.id &#x3D; aconsumerB:    group.id &#x3D; aconsumerC:    group.id &#x3D; bconsumerD:    group.id &#x3D; b</span><br></pre></td></tr></table></figure>

<p>再让consumerB也去消费TopicA的数据，它是消费不到了，但是我们在consumerC中重新指定一个另外的group.id，consumerC是可以消费到topicA的数据的。而consumerD也是消费不到的，所以在kafka中，<strong>不同组可有唯一的一个消费者去消费同一主题的数据</strong> 。</p>
<p>所以消费者组就是让多个消费者并行消费信息而存在的，而且它们不会消费到同一个消息，如下，consumerA，B，C是不会互相干扰的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer group:a    consumerA    consumerB    consumerC</span><br></pre></td></tr></table></figure>



<p><img src="https://pic2.zhimg.com/80/v2-90497c2375653342dc59458dc7543ff9_720w.jpg" alt="img"></p>
<p>如图，因为前面提到过了消费者会直接和leader建立联系，所以它们分别消费了三个leader，所以<strong>一个分区不会让消费者组里面的多个消费者去消费</strong> ，但是在消费者不饱和的情况下，<strong>一个消费者是可以去消费多个分区的数据的</strong> 。</p>
<h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>熟知一个规律：在大数据分布式文件系统里面，95%的都是主从式的架构，个别是对等式的架构，比如ElasticSearch。</p>
<p>kafka也是主从式的架构，主节点就叫controller，其余的为从节点，controller是需要和zookeeper进行配合管理整个kafka集群。</p>
<h2 id="kafka和zookeeper如何配合工作"><a href="#kafka和zookeeper如何配合工作" class="headerlink" title="kafka和zookeeper如何配合工作"></a>kafka和zookeeper如何配合工作</h2><p>kafka严重依赖于zookeeper集群（所以之前的zookeeper文章还是有点用的）。所有的broker在启动的时候都会往zookeeper进行注册，目的就是选举出一个controller，这个选举过程非常简单粗暴，就是一个谁先谁当的过程，不涉及什么算法问题。</p>
<p>那成为controller之后要做啥呢，它会监听zookeeper里面的多个目录，例如有一个目录/brokers/，其他从节点往这个目录上<strong>注册（就是往这个目录上创建属于自己的子目录而已）</strong> 自己，这时命名规则一般是它们的id编号，比如/brokers/0,1,2</p>
<p>注册时各个节点必定会暴露自己的主机名，端口号等等的信息，此时controller就要去<strong>读取注册上来的从节点的数据（通过监听机制），生成集群的元数据信息，之后把这些信息都分发给其他的服务器，让其他服务器能感知到集群中其它成员的存在</strong> 。</p>
<p>此时模拟一个场景，我们创建一个主题（其实就是在zookeeper上/topics/topicA这样创建一个目录而已），kafka会把分区方案生成在这个目录中，此时controller就监听到了这一改变，它会去同步这个目录的元信息，然后同样下放给它的从节点，通过这个方法让整个集群都得知这个分区方案，此时从节点就各自创建好目录等待创建分区副本即可。这也是整个集群的管理机制。</p>
<h2 id="加餐时间"><a href="#加餐时间" class="headerlink" title="加餐时间"></a>加餐时间</h2><h2 id="1-Kafka性能好在什么地方？"><a href="#1-Kafka性能好在什么地方？" class="headerlink" title="1.Kafka性能好在什么地方？"></a>1.Kafka性能好在什么地方？</h2><h3 id="①-顺序写"><a href="#①-顺序写" class="headerlink" title="① 顺序写"></a>① 顺序写</h3><p>操作系统每次从磁盘读写数据的时候，需要先寻址，也就是先要找到数据在磁盘上的物理位置，然后再进行数据读写，如果是机械硬盘，寻址就需要较长的时间。kafka的设计中，数据其实是存储在磁盘上面，一般来说，会把数据存储在内存上面性能才会好。但是kafka用的是顺序写，追加数据是追加到末尾，磁盘顺序写的性能极高，在磁盘个数一定，转数达到一定的情况下，基本和内存速度一致</p>
<p>随机写的话是在文件的某个位置修改数据，性能会较低。</p>
<h3 id="②-零拷贝"><a href="#②-零拷贝" class="headerlink" title="② 零拷贝"></a>② 零拷贝</h3><p>先来看看非零拷贝的情况</p>
<p><img src="https://pic2.zhimg.com/80/v2-ee7a1f19ae166325d0251f32bc7a49c9_720w.jpg" alt="img"></p>
<p>可以看到数据的拷贝从内存拷贝到kafka服务进程那块，又拷贝到socket缓存那块，整个过程耗费的时间比较高，kafka利用了Linux的sendFile技术（NIO），省去了进程切换和一次数据拷贝，让性能变得更好。</p>
<p><img src="https://pic3.zhimg.com/80/v2-a16b6969abf868b330fbfb8901f1746a_720w.jpg" alt="img"></p>
<h2 id="2-日志分段存储"><a href="#2-日志分段存储" class="headerlink" title="2.日志分段存储"></a>2.日志分段存储</h2><p>Kafka规定了一个分区内的.log文件最大为1G，做这个限制目的是为了方便把.log加载到内存去操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000000000000000.index00000000000000000000.log00000000000000000000.timeindex00000000000005367851.index00000000000005367851.log00000000000005367851.timeindex00000000000009936472.index00000000000009936472.log00000000000009936472.timeindex</span><br></pre></td></tr></table></figure>

<p>这个9936472之类的数字，就是代表了这个日志段文件里包含的起始offset，也就说明这个分区里至少都写入了接近1000万条数据了。Kafka broker有一个参数，log.segment.bytes，限定了每个日志段文件的大小，最大就是1GB，一个日志段文件满了，就自动开一个新的日志段文件来写入，避免单个文件过大，影响文件的读写性能，这个过程叫做log rolling，正在被写入的那个日志段文件，叫做active log segment。</p>
<p>如果大家有看前面的两篇有关于HDFS的文章时，就会发现NameNode的edits log也会做出限制，所以这些框架都是会考虑到这些问题。</p>
<h2 id="3-Kafka的网络设计"><a href="#3-Kafka的网络设计" class="headerlink" title="3.Kafka的网络设计"></a>3.Kafka的网络设计</h2><p>kafka的网络设计和Kafka的调优有关，这也是为什么它能支持高并发的原因</p>
<p><img src="https://pic2.zhimg.com/80/v2-ff67587f49d58e9d78a4185a54570ded_720w.jpg" alt="img"></p>
<p>首先客户端发送请求全部会先发送给一个Acceptor，broker里面会存在3个线程（默认是3个），这3个线程都是叫做processor，Acceptor不会对客户端的请求做任何的处理，直接封装成一个个socketChannel发送给这些processor形成一个队列，发送的方式是轮询，就是先给第一个processor发送，然后再给第二个，第三个，然后又回到第一个。消费者线程去消费这些socketChannel时，会获取一个个request请求，这些request请求中就会伴随着数据。</p>
<p>线程池里面默认有8个线程，这些线程是用来处理request的，解析请求，如果request是写请求，就写到磁盘里。读的话返回结果。processor会从response中读取响应数据，然后再返回给客户端。这就是Kafka的网络三层架构。</p>
<p>所以如果我们需要对kafka进行增强调优，增加processor并增加线程池里面的处理线程，就可以达到效果。request和response那一块部分其实就是起到了一个缓存的效果，是考虑到processor们生成请求太快，线程数不够不能及时处理的问题。</p>
<p>所以这就是一个加强版的reactor网络线程模型。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/16/kafka-base/" data-id="cka9oqkyc0014p4i09ci0a2hf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/kafka/" rel="tag">kafka</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kafka-基础概念" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/15/kafka-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2020-05-15T12:24:17.000Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/15/kafka-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">kafka 基础概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/15/kafka-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" data-id="cka9oqkxg0005p4i08a7f2m8d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kafka-单击测试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/15/kafka-%E5%8D%95%E5%87%BB%E6%B5%8B%E8%AF%95/" class="article-date">
  <time datetime="2020-05-15T11:36:39.000Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/15/kafka-%E5%8D%95%E5%87%BB%E6%B5%8B%E8%AF%95/">kafka 单机测试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="如下教程用来本地测试kafka流式数据处理功能"><a href="#如下教程用来本地测试kafka流式数据处理功能" class="headerlink" title="如下教程用来本地测试kafka流式数据处理功能"></a>如下教程用来本地测试kafka流式数据处理功能</h2><h3 id="zookeeper-安装"><a href="#zookeeper-安装" class="headerlink" title="zookeeper 安装"></a>zookeeper 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull wurstmeister&#x2F;zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="zookeeper启动"><a href="#zookeeper启动" class="headerlink" title="zookeeper启动"></a>zookeeper启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name zookeeper -p 2181 -t wurstmeister&#x2F;zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="kafka-安装"><a href="#kafka-安装" class="headerlink" title="kafka 安装"></a>kafka 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull wurstmeister&#x2F;kafka</span><br><span class="line">sudo docker run -d --name kafka --publish 9092:9092 \</span><br><span class="line">--link zookeeper \</span><br><span class="line">--env KAFKA_ZOOKEEPER_CONNECT&#x3D;zookeeper:2181 \</span><br><span class="line">--env KAFKA_ADVERTISED_HOST_NAME&#x3D;127.0.0.1 \</span><br><span class="line">--env KAFKA_ADVERTISED_PORT&#x3D;9092 --restart&#x3D;always \</span><br><span class="line">--volume &#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime \</span><br><span class="line">wurstmeister&#x2F;kafka</span><br></pre></td></tr></table></figure>

<h3 id="测试发送消息"><a href="#测试发送消息" class="headerlink" title="测试发送消息"></a>测试发送消息</h3><p>kafka内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -i -t $&#123;CONTAINER ID&#125; sh </span><br><span class="line">cd opt&#x2F;kafka_2.12-2.1.0</span><br><span class="line">创建主题</span><br><span class="line">bin&#x2F;kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 --partitions 1 --topic mykafka</span><br><span class="line">创建生产者</span><br><span class="line">bin&#x2F;kafka-console-producer.sh --broker-list localhost:9092 --topic mykafka</span><br><span class="line"></span><br><span class="line">新tty</span><br><span class="line">创建消费者</span><br><span class="line">bin&#x2F;kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic mykafka --from-beginning</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/15/kafka-%E5%8D%95%E5%87%BB%E6%B5%8B%E8%AF%95/" data-id="cka9oqkxe0004p4i0fbidgyop" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-uwsgi-gunicorn-区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/10/uwsgi-gunicorn-%E5%8C%BA%E5%88%AB/" class="article-date">
  <time datetime="2020-05-10T14:29:55.000Z" itemprop="datePublished">2020-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/10/uwsgi-gunicorn-%E5%8C%BA%E5%88%AB/">uwsgi gunicorn 区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://zhu327.github.io/2018/08/29/gunicorn与uwsgi之我见/" target="_blank" rel="noopener">https://zhu327.github.io/2018/08/29/gunicorn%E4%B8%8Euwsgi%E4%B9%8B%E6%88%91%E8%A7%81/</a></p>
<p><a href="https://blog.csdn.net/shudaqi2010/article/details/71172683" target="_blank" rel="noopener">https://blog.csdn.net/shudaqi2010/article/details/71172683</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/10/uwsgi-gunicorn-%E5%8C%BA%E5%88%AB/" data-id="cka9oqkxt000jp4i0f5uebm79" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-monkey-patch" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/10/monkey-patch/" class="article-date">
  <time datetime="2020-05-10T13:36:30.000Z" itemprop="datePublished">2020-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/10/monkey-patch/">monkey patch</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-gevent-模块简介"><a href="#1-gevent-模块简介" class="headerlink" title="1.gevent 模块简介"></a>1.gevent 模块简介</h3><p>​    gevent<strong>是一个基于</strong>libev<strong>的并发库。它为各种并发和网络相关的任务提供了整洁的</strong>API<em>*。</em></p>
<p>​    gevent<strong>中用到的主要模式是</strong>greenlet<strong>，</strong>它是以<strong>C</strong>扩展模块形式接入<strong>Python</strong>的轻量级协程。greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度</p>
<h3 id="2-gevent-程序举例"><a href="#2-gevent-程序举例" class="headerlink" title="2.gevent 程序举例"></a>2.gevent 程序举例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import gevent</span><br><span class="line"> </span><br><span class="line">def foo():</span><br><span class="line">    print(&#39;Running in foo&#39;)</span><br><span class="line">    gevent.sleep(0)</span><br><span class="line">    print(&#39;Explicit context switch to fooagain&#39;)</span><br><span class="line"> </span><br><span class="line">def bar():</span><br><span class="line">    print(&#39;Explicit context to bar&#39;)</span><br><span class="line">    gevent.sleep(0)</span><br><span class="line">    print(&#39;Implicit context switch back tobar&#39;)</span><br><span class="line"> </span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(foo),</span><br><span class="line">    gevent.spawn(bar),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import gevent</span><br><span class="line">import random</span><br><span class="line"> </span><br><span class="line">def task(pid):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Some non-deterministic task</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    gevent.sleep(random.randint(0,2)*0.001)</span><br><span class="line">    print(&#39;Task %s done&#39; % pid)</span><br><span class="line"> </span><br><span class="line">def synchronous():</span><br><span class="line">    for i in range(1,10):</span><br><span class="line">        task(i)</span><br><span class="line"> </span><br><span class="line">def asynchronous():</span><br><span class="line">    threads &#x3D; [gevent.spawn(task, i) for i inxrange(10)]</span><br><span class="line">    gevent.joinall(threads)</span><br><span class="line"> </span><br><span class="line">print(&#39;Synchronous:&#39;)</span><br><span class="line">synchronous()</span><br><span class="line"> </span><br><span class="line">print(&#39;Asynchronous:&#39;)</span><br><span class="line">asynchronous()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import gevent</span><br><span class="line">from gevent importselect</span><br><span class="line"> </span><br><span class="line">start &#x3D; time.time()</span><br><span class="line">tic &#x3D; lambda: &#39;at%1.1f seconds&#39; % (time.time() - start)</span><br><span class="line"> </span><br><span class="line">def gr1():</span><br><span class="line">    # Busy waits for a second, but we don&#39;twant to stick around...</span><br><span class="line">    print(&#39;Started Polling: %s&#39; % tic())</span><br><span class="line">    select.select([], [], [], 2)</span><br><span class="line">    print(&#39;Ended Polling: %s&#39; % tic())</span><br><span class="line"> </span><br><span class="line">def gr2():</span><br><span class="line">    # Busy waits for a second, but we don&#39;twant to stick around...</span><br><span class="line">    print(&#39;Started Polling: %s&#39; % tic())</span><br><span class="line">    select.select([], [], [], 2)</span><br><span class="line">    print(&#39;Ended Polling: %s&#39; % tic())</span><br><span class="line"> </span><br><span class="line">def gr3():</span><br><span class="line">    print(&quot;Hey lets do some stuff whilethe greenlets poll, %s&quot; % tic())</span><br><span class="line">    gevent.sleep(1)</span><br><span class="line"> </span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(gr1),</span><br><span class="line">    gevent.spawn(gr2),</span><br><span class="line">    gevent.spawn(gr3),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>



<p>备注：</p>
<p><em>（<strong>1</strong>）程序的重要部分是将任务<strong>函数封装到gevent.spawn。初始化的greenlet列表存放在数组threads中，此数组被传给gevent.joinall 函数，gevent.joinall</strong>会<strong>阻塞当前流程，并执行所有给定的greenlet</strong>，**执行流程只会在所有greenlet执行完后才会继续向下走。</em></p>
<p><em>（<strong>2</strong>）<strong>gevent实现了python标准库里面大部分的阻塞式系统调用，包括socket、ssl、threading和select等模块，而将这些阻塞式调用变为协作式运行</strong>（参见猴子补丁部分）。</em></p>
<h3 id="3-猴子补丁Monkey-Patch"><a href="#3-猴子补丁Monkey-Patch" class="headerlink" title="3 猴子补丁Monkey Patch"></a>3 猴子补丁Monkey Patch</h3><p><em>（1）猴子补丁的由来</em></p>
<p>​     <em>猴子补丁的这个叫法起源于**Zope框架，大家在修正Zope的Bug的时候经常在程序后面追加更新部分，这些被称作是“杂牌军补丁(guerillapatch)”，后来guerilla就渐渐的写成了gorllia(猩猩)，再后来就写了monkey(猴子)，所以猴子补丁的叫法是这么莫名其妙的得来的。</em></p>
<p>​     <em>后来在动态语言中，不改变源代码而对功能进行追加和变更，统称为“猴子补丁”。所以猴子补丁并不是Python中专有的。猴子补丁这种东西充分利用了动态语言的灵活性，可以对现有的语言**Api进行追加，替换，修改Bug，甚至性能优化等等。</em></p>
<p>  使用猴子补丁的方式，gevent能够修改标准库里面大部分的阻塞式系统调用，包括socket、ssl、threading和 select等模块，而变为协作式运行。也就是通过猴子补丁的<em>monkey.patch_xxx()<strong>来将</strong>python<strong>标准库中模块或函数改成</strong>gevent**中的响应的具有协程的协作式对象。这样在不改变原有代码的情况下，将应用的阻塞式方法，变成协程式的。</em></p>
<p><em>（2）猴子补丁使用时的注意事项</em></p>
<p>  <strong>猴子补丁的功能很强大，但是也带来了很多的风险，尤其是像</strong>gevent这种直接进行API替换的补丁，整个Python进程所使用的模块都会被替换，可能自己的代码能hold住，但是其它第三方库，有时候问题并不好排查，即使排查出来也是很棘手，所以，就像松本建议的那样，如果要使用猴子补丁，那么只是做功能追加，尽量避免大规模的API覆盖</p>
<p> <em>虽然猴子补丁仍然是邪恶的(evil)，但在这种情况下它是“有用的邪恶(useful evil)”。</em></p>
<p><em>（3）python中使用gevent的猴子补丁的举例</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import socket</span><br><span class="line">print(socket.socket)</span><br><span class="line"> </span><br><span class="line">print(&quot;Aftermonkey patch&quot;)</span><br><span class="line">from gevent importmonkey</span><br><span class="line">monkey.patch_socket()</span><br><span class="line">print(socket.socket)</span><br><span class="line"> </span><br><span class="line">import select</span><br><span class="line">print(select.select)</span><br><span class="line">monkey.patch_select()</span><br><span class="line">print(&quot;Aftermonkey patch&quot;)</span><br><span class="line">print(select.select)</span><br></pre></td></tr></table></figure>

<p>python中使用补丁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Example():</span><br><span class="line">    def func1(self):</span><br><span class="line">        print(&#39;我才是原装&#39;)</span><br><span class="line"></span><br><span class="line">def func2(*args):</span><br><span class="line">    print(&#39;我要取代你&#39;)</span><br><span class="line"></span><br><span class="line">def func3(*args):</span><br><span class="line">    print(&#39;都给我一边去&#39;)</span><br><span class="line"></span><br><span class="line">instance &#x3D; Example()</span><br><span class="line">Example.func1 &#x3D; func2</span><br><span class="line">instance.func1() # 我要取代你</span><br><span class="line">instance.func1 &#x3D; func3</span><br><span class="line">instance.func1() # 都给我一边去</span><br><span class="line">instance2 &#x3D; Example()</span><br><span class="line">instance2.func1() # 我要取代你</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/10/monkey-patch/" data-id="cka9oqkxk0009p4i00l3zevdd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-uwsgi-wsgi-WSGI-区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/10/uwsgi-wsgi-WSGI-%E5%8C%BA%E5%88%AB/" class="article-date">
  <time datetime="2020-05-10T13:32:12.000Z" itemprop="datePublished">2020-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/10/uwsgi-wsgi-WSGI-%E5%8C%BA%E5%88%AB/">uwsgi wsgi WSGI 区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h2><p>英文全称：Web Server Gateway Interface，Web服务网管接口，简单来说它是一种Web服务器和应用程序间的通信规范。</p>
<h2 id="uwsgi"><a href="#uwsgi" class="headerlink" title="uwsgi"></a>uwsgi</h2><p>uwsgi是一种通信协议，不过跟WSGI分属两种东西，该协议下速度比较快。</p>
<h2 id="uWSGI"><a href="#uWSGI" class="headerlink" title="uWSGI"></a>uWSGI</h2><p>uWSGI是一个Web Server，并且独占uwsgi协议，但是同时支持WSGI协议、HTTP协议等，它的功能是把HTTP协议转化成语言支持的网络协议供python使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/10/uwsgi-wsgi-WSGI-%E5%8C%BA%E5%88%AB/" data-id="cka9oqkxu000lp4i05wgn845d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-基本操作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/10/mysql-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2020-05-10T12:52:19.000Z" itemprop="datePublished">2020-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/10/mysql-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">mysql 基本操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#39;newuser&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39;;</span><br><span class="line">GRANT ALL PRIVILEGES ON * . * TO &#39;newuser&#39;@&#39;localhost&#39;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<h2 id="How-To-Grant-Different-User-Permissions"><a href="#How-To-Grant-Different-User-Permissions" class="headerlink" title="How To Grant Different User Permissions"></a>How To Grant Different User Permissions</h2><p>Here is a short list of other common possible permissions that users can enjoy.</p>
<ul>
<li>ALL PRIVILEGES- as we saw previously, this would allow a MySQL user full access to a designated database (or if no database is selected, global access across the system)</li>
<li>CREATE- allows them to create new tables or databases</li>
<li>DROP- allows them to them to delete tables or databases</li>
<li>DELETE- allows them to delete rows from tables</li>
<li>INSERT- allows them to insert rows into tables</li>
<li>SELECT- allows them to use the <code>SELECT</code> command to read through databases</li>
<li>UPDATE- allow them to update table rows</li>
<li>GRANT OPTION- allows them to grant or remove other users’ privileges</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT type_of_permission ON database_name.table_name TO ‘username’@&#39;localhost’;</span><br></pre></td></tr></table></figure>

<p>To provide a specific user with a permission, you can use this framework:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT type_of_permission ON database_name.table_name TO ‘username’@&#39;localhost’;</span><br></pre></td></tr></table></figure>

<p>If you want to give them access to any database or to any table, make sure to put an asterisk (*) in the place of the database name or table name.</p>
<p>Each time you update or change a permission be sure to use the Flush Privileges command.</p>
<p>If you need to revoke a permission, the structure is almost identical to granting it:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE type_of_permission ON database_name.table_name FROM ‘username’@‘localhost’;</span><br></pre></td></tr></table></figure>

<p>Note that when revoking permissions, the syntax requires that you use <code>FROM</code>, instead of <code>TO</code> as we used when granting permissions.</p>
<p>You can review a user’s current permissions by running the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS username;</span><br></pre></td></tr></table></figure>

<p>Just as you can delete databases with DROP, you can use DROP to delete a user altogether:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER ‘username’@‘localhost’;</span><br></pre></td></tr></table></figure>

<p>To test out your new user, log out by typing:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure>

<p>and log back in with this command in terminal:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u [username] -p</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/10/mysql-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" data-id="cka9oqkxm000cp4i0bz3ueoeh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库ACID" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93ACID/" class="article-date">
  <time datetime="2020-05-10T06:24:32.000Z" itemprop="datePublished">2020-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93ACID/">数据库ACID</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>定义：所谓事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。</p>
<p>准备工作：为了说明事务的ACID原理，我们使用银行账户及资金管理的案例进行分析。</p>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><p>ACID，是指在可靠数据库管理系统（DBMS）中，事务(transaction)所应该具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）</p>
<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p> 原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<p>保障事务的原子性是数据库管理系统的责任，为此许多数据源采用日志机制。例如，SQL Server使用一个预写事务日志，在将数据提交到实际数据页面前，先写在事务日志上。</p>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</p>
<p>如何保证：</p>
<p>数据库机制层面</p>
<p>​    数据库层面的一致性是，在一个事务执行之前和之后，数据会符合你设置的约束（唯一约束，外键约束,Check约束等)和触发器设置。这一点是由SQL SERVER进行保证的。比如转账，则可以使用CHECK约束两个账户之和等于2000来达到一致性目的</p>
<p>业务层面</p>
<p>  对于业务层面来说，一致性是保持业务的一致性。这个业务一致性需要由开发人员进行保证。当然，很多业务方面的一致性，也可以通过转移到数据库机制层面进行保证。</p>
<h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</p>
<p>这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p>
<p> 事务之间的相互影响分为几种，分别为：脏读，不可重复读，幻读，丢失更新</p>
<ul>
<li><p>脏读</p>
<p>一个事务读取了另一个事务未提交的数据，而这个数据是有可能回滚的</p>
</li>
<li><p>不可重复读</p>
<p>在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。</p>
</li>
<li><p>丢失更新</p>
<p>两个事务同时读取同一条记录，A先修改记录，B也修改记录（B是不知道A修改过），B提交数据后B的修改结果覆盖了A的修改结果。</p>
</li>
</ul>
<h3 id="理解SQL-SERVER中的隔离级别"><a href="#理解SQL-SERVER中的隔离级别" class="headerlink" title="理解SQL SERVER中的隔离级别"></a>理解SQL SERVER中的隔离级别</h3><p>数据库的事务隔离级别（TRANSACTION ISOLATION LEVEL）是一个数据库上很基本的一个概念。为什么会有事务隔离级别，SQL Server上实现了哪些事务隔离级别？事务隔离级别的前提是一个多用户、多进程、多线程的并发系统，在这个系统中为了保证数据的一致性和完整性，我们引入了事务隔离级别这个概念，对一个单用户、单线程的应用来说则不存在这个问题。</p>
<p>  为了避免上述几种事务之间的影响，SQL Server通过设置不同的隔离级别来进行不同程度的避免。因为高的隔离等级意味着更多的锁，从而牺牲性能。所以这个选项开放给了用户根据具体的需求进行设置。不过默认的隔离级别Read Commited符合了多数的实际需求.</p>
<table>
<thead>
<tr>
<th><strong>隔离级别</strong></th>
<th><strong>脏读</strong></th>
<th><strong>丢失更新</strong></th>
<th><strong>不可重复读</strong></th>
<th><strong>幻读</strong></th>
<th><strong>并发模型</strong></th>
<th><strong>更新冲突检测</strong></th>
</tr>
</thead>
<tbody><tr>
<td>未提交读：Read Uncommited</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>悲观</td>
<td>否</td>
</tr>
<tr>
<td>已提交读：Read commited</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>悲观</td>
<td>否</td>
</tr>
<tr>
<td>可重复读：Repeatable Read</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>悲观</td>
<td>否</td>
</tr>
<tr>
<td>可串行读：Serializable</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>悲观</td>
<td>否</td>
</tr>
</tbody></table>
<p>SQL Server隔离事务之间的影响是通过锁来实现的，通过阻塞来阻止上述影响。不同的隔离级别是通过加不同的锁，造成阻塞来实现的，所以会以付出性能作为代价；安全级别越高，处理效率越低；安全级别越低，效率高。</p>
<p>​    <strong><em>\</em>使用方法：**</strong>SET TRANSACTIONISOLATION LEVEL REPEATABLE READ</p>
<p>​    <strong><em>\</em>未提交读：**</strong> 在读数据时不会检查或使用任何锁。因此，在这种隔离级别中可能读取到没有提交的数据。 </p>
<p>​    <strong><em>\</em>已提交读：**</strong>只读取提交的数据并等待其他事务释放排他锁。读数据的共享锁在读操作完成后立即释放。已提交读是SQL Server的默认隔离级别。 </p>
<p>​    <strong><em>\</em>可重复读：**</strong> 像已提交读级别那样读数据，但会保持共享锁直到事务结束。 </p>
<p>​    <strong>可串行读：</strong>工作方式类似于可重复读。但它不仅会锁定受影响的数据，还会锁定这个范围。这就阻止了新数据插入查询所涉及的范围。</p>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。    </p>
<p>即使出现了任何事故比如断电等，事务一旦提交，则持久化保存在数据库中。</p>
<p>​    SQL SERVER通过write-ahead transaction log来保证持久性。write-ahead transaction log的意思是，事务中对数据库的改变在写入到数据库之前，首先写入到事务日志中。而事务日志是按照顺序排号的（LSN）。当数据库崩溃或者服务器断点时，重启动SQL SERVER，SQLSERVER首先会检查日志顺序号，将本应对数据库做更改而未做的部分持久化到数据库，从而保证了持久性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93ACID/" data-id="cka9oqkxz000sp4i06bapdn36" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux-如何查看python-调用栈" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/10/linux-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Bpython-%E8%B0%83%E7%94%A8%E6%A0%88/" class="article-date">
  <time datetime="2020-05-10T04:37:36.000Z" itemprop="datePublished">2020-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/10/linux-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Bpython-%E8%B0%83%E7%94%A8%E6%A0%88/">linux 如何查看python 调用栈</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="PDB"><a href="#PDB" class="headerlink" title="PDB"></a>PDB</h2><ul>
<li><strong>非侵入式方法</strong>（不用额外修改源代码，在命令行下直接运行就能调试）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pdb filename.py</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>侵入式方法</strong>（需要在被调试的代码中添加一行代码然后再正常运行代码）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import pdb;pdb.set_trace()</span><br></pre></td></tr></table></figure>

<p>当你在命令行看到下面这个提示符时，说明已经正确打开了pdb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Pdb)</span><br></pre></td></tr></table></figure>

<p>然后就可以开始输入pdb命令了，下面是pdb的常用命令</p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l</span><br></pre></td></tr></table></figure>

<p>查看当前位置前后11行源代码（多次会翻页）<br>当前位置在代码中会用–&gt;这个符号标出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">b lineno</span><br><span class="line">b filename:lineno </span><br><span class="line">b functionname</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<p>filename文件名，断点添加到哪个文件，如test.py<br>lineno断点添加到哪一行<br>function：函数名，在该函数执行的第一行设置断点</p>
<p>说明：</p>
<p>1.不带参数表示查看断点设置<br>2.带参则在指定位置设置一个断点</p>
<p><strong>清除断点</strong></p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cl</span><br><span class="line">cl filename:lineno</span><br><span class="line">cl bpnumber [bpnumber ...]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<p>bpnumber 断点序号（多个以空格分隔）</p>
<p>说明：</p>
<p>1.不带参数用于清除所有断点，会提示确认（包括临时断点）<br>2.带参数则清除指定文件行或当前文件指定序号的断点</p>
<p><strong>打印变量值</strong></p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p expression</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<p>expression Python表达式</p>
<p><strong>逐行调试命令</strong></p>
<p>包括 s ，n ， r 这3个相似的命令，区别在如何对待函数上</p>
<p>命令1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>执行下一行（能够进入函数体）</p>
<p>命令2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>执行下一行（不会进入函数体）</p>
<p>命令3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>执行下一行（在函数中时会直接执行到函数返回处）</p>
<h2 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h2><p>strace有两种运行模式。</p>
<p>一种是通过它启动要跟踪的进程。用法很简单，在原本的命令前加上strace即可。比如我们要跟踪 “ls -lh /var/log/messages” 这个命令的执行，可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace ls -lh &#x2F;var&#x2F;log&#x2F;messages</span><br></pre></td></tr></table></figure>

<p>另外一种运行模式，是跟踪已经在运行的进程，在不中断进程执行的情况下，理解它在干嘛。 这种情况，给strace传递个-p pid 选项即可。</p>
<p>比如，有个在运行的some_server服务，第一步，查看pid:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidof some_server            17553</span><br></pre></td></tr></table></figure>

<p>得到其pid 17553然后就可以用strace跟踪其执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -p 17553</span><br></pre></td></tr></table></figure>

<p>完成跟踪时，按ctrl + C 结束strace即可。</p>
<p>常用选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-tt 在每行输出的前面，显示毫秒级别的时间</span><br><span class="line">-T 显示每次系统调用所花费的时间</span><br><span class="line">-v 对于某些相关调用，把完整的环境变量，文件stat结构等打出来。</span><br><span class="line">-f 跟踪目标进程，以及目标进程创建的所有子进程</span><br><span class="line">-e 控制要跟踪的事件和跟踪行为,比如指定要跟踪的系统调用名称</span><br><span class="line">-o 把strace的输出单独写到指定的文件</span><br><span class="line">-s 当系统调用的某个参数是字符串时，最多输出指定长度的内容，默认是32个字节</span><br><span class="line">-p 指定要跟踪的进程pid, 要同时跟踪多个pid, 重复多次-p选项即可。</span><br></pre></td></tr></table></figure>

<p>strace 定位问题:</p>
<p>定位进程异常退出</p>
<p>定位共享内存异常</p>
<p>性能分析</p>
<p><strong>常见系统调用:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">open() : 用于打开或创建一个文件。</span><br><span class="line">read() : 用于读取一个文件。</span><br><span class="line">write() : 写文件。</span><br><span class="line">connect() : 建立网络连接。</span><br><span class="line">sendto() : 发送网络数据。</span><br><span class="line">recvfrom() : 接收网络数据。</span><br><span class="line">futex() : 锁相关操作。</span><br></pre></td></tr></table></figure>

<p><a href="http://doc.codingdict.com/python_352/library/debug.html" target="_blank" rel="noopener">其他调试方法</a>,profile,cprofile</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/10/linux-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Bpython-%E8%B0%83%E7%94%A8%E6%A0%88/" data-id="cka9oqkxj0008p4i05zts7l7w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-进程假死现象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/10/%E8%BF%9B%E7%A8%8B%E5%81%87%E6%AD%BB%E7%8E%B0%E8%B1%A1/" class="article-date">
  <time datetime="2020-05-10T04:34:30.000Z" itemprop="datePublished">2020-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/10/%E8%BF%9B%E7%A8%8B%E5%81%87%E6%AD%BB%E7%8E%B0%E8%B1%A1/">进程假死现象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>所谓假死现象，是指 Linux 内核 Alive，但是其上的某个或所有操作的响应变得很慢的现象。</p>
<p>具体比较常见的现象有如下几种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 能 Ping 通访问的服务器。</span><br><span class="line">2. 系统负载非常的高。(内存耗光,CPU满负载,超负荷工作,无法响应,服务器tcp队列处于阻塞状态)</span><br><span class="line">3. SSH 不能登陆或者登陆比较慢。</span><br><span class="line">4. 服务器上提供的服务都不能正常响应，比如：不能访问系统上部署的 Web 服务器所提供的页面。</span><br><span class="line">5. 在系统上做任何其它操作都没有反应或者反应较慢。</span><br></pre></td></tr></table></figure>

<ul>
<li>假死现象并不是经常出现</li>
</ul>
<p>Linux 作为一个多任务操作系统，要把系统忙死，忙到 SSH 都连不上去也不是那么容易的。尤其是现在的系统还有 FD 保护、进程数保护、最大内存保护之类的机制。</p>
<p>你可以尝试 Fork 很多进程，系统会变得很慢，但是 SSH 通常还是能连上去的；你可以尝试分配很多内存，但是内存多到一定程度 Linux 的 OOM 机制的 Killer 进程就会杀掉你的进程，来保证其它服务能正常工作。</p>
<ul>
<li>假死现象是如何出现的</li>
</ul>
<p>有一个确定可以把系统搞成假死的办法是：主进程分配固定内存，然后不停的 Fork，并且在子进程里面 Sleep(100)。</p>
<p>也就是说，当主进程不停 Fork 的时候，很快会把系统的物理内存用完。当物理内存不足时候，系统会开始使用 Swap。那么当 Swap 不足时会触发 OOM 机制的 Killer 进程来杀掉多余进程。</p>
<p>当 OOM 机制的 Killer 进程杀掉了子进程，主进程会立刻 Fork 新的子进程，并再次导致内存用完并再次触发 OOM 机制的 Killer 进程杀掉子进程，于是就进入死循环。而且 OOM Killer 进程是系统底层优先级很高的内核线程，此时也参与到这个死循环中，长此以往系统资源就会被消耗殆尽。</p>
<ul>
<li>系统出现假死现象后，为何还能 Ping 通但又无法建立新的网络连接</li>
</ul>
<p>系统出现假死现象后，服务器还可以 Ping 通，但是无法建立新的网络连接。比如：SSH 无法连上去。这是由于 Ping 是在 Linux 系统底层 ( Kernel )处理的，并没有参与进程调度。而 SSHD 是要参与进程调度，但是优先级没 OOM 机制的 Killer 进程高。这样就会一直得不到系统调度，从而始终无法正确的提供服务来与 SSH 客户端建立新的连接。</p>
<ul>
<li>Linux 出现假死现象，我们应该怎么办?</li>
</ul>
<p>为什么要费那么大的力气把服务器搞死呢？我们知道假死是怎么产生的即可，这样可以针对假死的原因进行预防。 其实假死的情况很少发生，通常只有代码出现 Bug 很多的情况或者某个服务进程未正确配置的情况下才会出现。</p>
<p>建议使用 nice 命令将 SSHD 的进程优先级调高，这样当系统内存紧张时，还能勉强登陆服务器进行调试，然后分析故障。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/10/%E8%BF%9B%E7%A8%8B%E5%81%87%E6%AD%BB%E7%8E%B0%E8%B1%A1/" data-id="cka9oqky0000up4i0215f1u32" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Django/" rel="tag">Django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/kafka/" rel="tag">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/peocess/" rel="tag">peocess</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/Django/" style="font-size: 10px;">Django</a> <a href="/blog/tags/kafka/" style="font-size: 10px;">kafka</a> <a href="/blog/tags/linux/" style="font-size: 15px;">linux</a> <a href="/blog/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/blog/tags/peocess/" style="font-size: 10px;">peocess</a> <a href="/blog/tags/python/" style="font-size: 20px;">python</a> <a href="/blog/tags/redis/" style="font-size: 10px;">redis</a> <a href="/blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 15px;">中间件</a> <a href="/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">数据结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2020/05/16/kafka-base/">kafka base</a>
          </li>
        
          <li>
            <a href="/blog/2020/05/15/kafka-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">kafka 基础概念</a>
          </li>
        
          <li>
            <a href="/blog/2020/05/15/kafka-%E5%8D%95%E5%87%BB%E6%B5%8B%E8%AF%95/">kafka 单机测试</a>
          </li>
        
          <li>
            <a href="/blog/2020/05/10/uwsgi-gunicorn-%E5%8C%BA%E5%88%AB/">uwsgi gunicorn 区别</a>
          </li>
        
          <li>
            <a href="/blog/2020/05/10/monkey-patch/">monkey patch</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 wuguobin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">

  
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>




<script src="/blog/js/script.js"></script>




  </div>
</body>
</html>