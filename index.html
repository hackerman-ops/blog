<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Make it different</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Make it different">
<meta property="og:url" content="https://hackerman-ops.github.io/blog/index.html">
<meta property="og:site_name" content="Make it different">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="wuguobin">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/blog/atom.xml" title="Make it different" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/blog/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Make it different</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">stay hungry, stay foolish</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://hackerman-ops.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-django-安全编码问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/17/django-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-05-17T14:57:16.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/17/django-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/">django 安全编码问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从浏览器传过来的任何性质的数据，都需要近乎狂热地接受检查。 这包括用户数据（比如Web表单提交的内容）和带外数据（比如，HTTP头、cookies以及其他信息）。 要修改那些浏览器自动添加的元数据，是一件很容易的事。</p>
<h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>在SQL注入中，攻击者改变web网页的参数（例如 <code>GET</code> /<code>POST</code> 数据或者URL地址），加入一些其他的SQL片段。 未加处理的网站会将这些信息在后台数据库直接运行。</p>
<p>绝不信任用户提交的数据，并且在传递给SQL语句时，总是转义它。</p>
<p>quato_name 函数</p>
<h3 id="跨站点脚本-XSS"><a href="#跨站点脚本-XSS" class="headerlink" title="跨站点脚本 (XSS)"></a>跨站点脚本 (XSS)</h3><p><em>跨站点脚本</em> (XSS)有时在被渲染成HTML之前，不能恰当地对用户提交的内容进行转义。 这使得攻击者能够向你的网站页面插入通常以 `` 标签形式的任意HTML代码。</p>
<p>总是转义可能来自某个用户的任何内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from django.shortcuts import render_to_response</span><br><span class="line"></span><br><span class="line">def say_hello(request):</span><br><span class="line">    name &#x3D; request.GET.get(&#39;name&#39;, &#39;world&#39;)</span><br><span class="line">    return render_to_response(&#39;hello.html&#39;, &#123;&#39;name&#39;: name&#125;)</span><br><span class="line"></span><br><span class="line"># hello.html</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;Hello, &lt;i&gt;Jacob&lt;&#x2F;i&gt;!&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>

<h3 id="伪造跨站点请求"><a href="#伪造跨站点请求" class="headerlink" title="伪造跨站点请求"></a>伪造跨站点请求</h3><p>伪造跨站点请求(CSRF)发生在当某个恶意Web站点诱骗用户不知不觉的从一个信任站点下载某个URL之时，这个信任站点已经被通过信任验证，因此恶意站点就利用了这个被信任状态。</p>
<p>Django拥有内建工具来防止这种攻击</p>
<h4 id="使用CSRF中间件"><a href="#使用CSRF中间件" class="headerlink" title="使用CSRF中间件"></a>使用CSRF中间件</h4><p><code>django.contrib.csrf</code> 开发包只有一个模块： <code>middleware.py</code> 。该模块包含了一个 Django 中间件类—— <code>CsrfMiddleware</code> ，该类实现了 CSRF 防护功能。</p>
<p>在设置文件中将 <code>&#39;django.contrib.csrf.middleware.CsrfMiddleware&#39;</code> 添加到 <code>MIDDLEWARE_CLASSES</code> 设置中可激活 CSRF 防护。 该中间件必须在 <code>SessionMiddleware</code> <em>之后</em> 执行，因此在列表中 <code>CsrfMiddleware</code> 必须出现在 <code>SessionMiddleware</code> <em>之前</em> （因为响应中间件是自后向前执行的）。 同时，它也必须在响应被压缩或解压之前对响应结果进行处理，因此 <code>CsrfMiddleware</code> 必须在 <code>GZipMiddleware</code> 之后执行。一旦将它添加到<code>MIDDLEWARE_CLASSES</code>设置中，你就完成了工作。 参见第十五章的“MIDDLEWARE_CLASSES顺序”小节以了解更多。</p>
<p>如果感兴趣的话，下面是 <code>CsrfMiddleware</code> 的工作模式。 它完成以下两项工作：</p>
<ol>
<li>它修改当前处理的请求，向所有的 <code>POST</code> 表单增添一个隐藏的表单字段，使用名称是 <code>csrfmiddlewaretoken</code> ，值为当前会话 ID 加上一个密钥的散列值。 如果未设置会话 ID ，该中间件将 <em>不会</em> 修改响应结果，因此对于未使用会话的请求来说性能损失是可以忽略的。</li>
</ol>
<ol>
<li>对于所有含会话 cookie 集合的传入 <code>POST</code> 请求，它将检查是否存在 <code>csrfmiddlewaretoken</code> 及其是否正确。 如果不是的话，用户将会收到一个 403 <code>HTTP</code> 错误。 403 错误页面的内容是检测到了跨域请求伪装。 终止请求。</li>
</ol>
<p>该步骤确保只有源自你的站点的表单才能将数据 POST 回来。</p>
<p>该中间件特意只针对 HTTP <code>POST</code> 请求（以及对应的 POST 表单）。 如我们所解释的，永远不应该因为使用了 <code>GET</code> 请求而产生负面效应，你必须自己来确保这一点。</p>
<p>未使用会话 cookie 的 <code>POST</code> 请求无法受到保护，但它们也不 <em>需要</em> 受到保护，因为恶意网站可用任意方法来制造这种请求。</p>
<p>为了避免转换非 HTML 请求，中间件在编辑响应结果之前对它的 <code>Content-Type</code> 头标进行检查。 只有标记为 <code>text/html</code> 或 <code>application/xml+xhtml</code> 的页面才会被修改。</p>
<h3 id="会话伪造-劫持"><a href="#会话伪造-劫持" class="headerlink" title="会话伪造/劫持"></a>会话伪造/劫持</h3><p>对用户会话数据的通用类攻击。 这种攻击可以采取多种形式：</p>
<blockquote>
<p><em>中间人</em> 攻击：检索所在有线（无线）网络，监听会话数据。</p>
<p><em>伪造会话</em> ：攻击者利用会话ID（可能是通过中间人攻击来获得）将自己伪装成另一个用户。</p>
<p>这两种攻击的一个例子可以是在一间咖啡店里的某个攻击者利用店内的无线网络来捕获某个会话cookie，然后她就可以利用那个cookie来假冒原始用户。 她便可以使该cookie来模拟原始用户。</p>
<p><em>伪造cookie</em> ：就是指某个攻击者覆盖了在某个cookie中本应该是只读的数据。 <code>第十四章 &lt;../chapter14/&gt;</code>__ 详细介绍了cookies如何工作，以及要点之一的是，它在你不知道的情况下无视浏览器和恶意用户私自改变cookies。</p>
<p>Web站点以 <code>IsLoggedIn=1</code> 或者 <code>LoggedInAsUser=jacob</code> 这样的方式来保存cookie由来已久，使用这样的cookie是再简单不过的了。</p>
<p>一个更微妙的层面上，然而，相信在cookies中存储的任意信息绝对不是一个好主意。 你永远不知道谁一直在作怪。</p>
<p><em>会话滞留</em> ：攻击者诱骗用户设置或者重设置该用户的会话ID。</p>
<p>例如，PHP允许在URL（如 <code>http://example.com/?PHPSESSID=fa90197ca25f6ab40bb1374c510d7a32</code> 等）中传递会话标识符。攻击者欺骗用户点击一个硬编码会话ID的链接，这回导致用户转到那个会话。</p>
<p>会话滞留已经运用在钓鱼攻击中，以诱骗用户在攻击者拥有的账号里输入其个人信息。 他可以稍后登陆账户并且检索数据。</p>
<p><em>会话中毒</em> ：攻击者通过用户提交设置会话数据的Web表单向该用户会话中注入潜在危险数据。</p>
<p>一个经典的例子就是一个站点在某个cookie中存储了简单的用户偏好（比如一个页面背景颜色）。 攻击者可以诱骗用户点击一个链接来提交背景颜色，实际上包含了一个XSS攻击。 如果颜色没有转义，那么就可以再把恶意代码注入到用户环境中。</p>
</blockquote>
<p><strong>解决方案：</strong></p>
<blockquote>
<p>不要在URL中包含任何session信息。</p>
<p>Django的session框架（参见<code>第十四章 &lt;../chapter14/&gt;</code>__ ）根本不会容许session包含在URL中。</p>
<p>不要直接在cookie中保存数据。 相反，存储一个在后台映射到session数据存储的session ID。</p>
<p>如果使用Django内置的session框架（即 <code>request.session</code> ），它会自动进行处理。 这个session框架仅在cookie中存储一个session ID，所有的session数据将会被存储在数据库中。</p>
<p>如果需要在模板中显示session数据，要记得对其进行转义。 可参考之前的XSS部分，对所有用户提交的数据和浏览器提交的数据进行转义。 对于session信息，应该像用户提交的数据一样对其进行处理。</p>
<p>任何可能的地方都要防止攻击者进行session欺骗。</p>
<p>尽管去探测究竟是谁劫持了会话ID是几乎不可能的事儿，Django还是内置了保护措施来抵御暴力会话攻击。 会话ID被存在哈希表里（取代了序列数字），这样就阻止了暴力攻击，并且如果一个用户去尝试一个不存在的会话那么她总是会得到一个新的会话ID，这样就阻止了会话滞留。</p>
</blockquote>
<p>请注意，以上没有一种准则和工具能够阻止中间人攻击。 这些类型的攻击是几乎不可能被探测的。 如果你的站点允许登陆用户去查看任意敏感数据的话，你应该 <em>总是</em> 通过HTTPS来提供网站服务。 此外，如果你的站点使用SSL，你应该将 <code>SESSION_COOKIE_SECURE</code> 设置为 <code>True</code> ，这样就能够使Django只通过HTTPS发送会话cookie。</p>
<h3 id="邮件头部注入"><a href="#邮件头部注入" class="headerlink" title="邮件头部注入"></a>邮件头部注入</h3><p><em>邮件头部注入</em> ：SQL注入的兄弟，是一种通过劫持发送邮件的Web表单的攻击方式。 攻击者能够利用这种技术来通过你的邮件服务器发送垃圾邮件。 在这种攻击面前，任何方式的来自Web表单数据的邮件头部构筑都是非常脆弱的。</p>
<p>让我们看看在我们许多网站中发现的这种攻击的形式。 通常这种攻击会向硬编码邮件地址发送一个消息，因此，第一眼看上去并不显得像面对垃圾邮件那么脆弱。</p>
<p>但是，大多数表单都允许用户输入自己的邮件主题（同时还有from地址，邮件体，有时还有部分其他字段）。 这个主题字段被用来构建邮件消息的主题头部。</p>
<p>如果那个邮件头部在构建邮件信息时没有被转义，那么攻击者可以提交类似 <code>&quot;hello\ncc:spamvictim@example.com&quot;</code> （这里的 <code>&quot;\n&quot;</code> 是换行符）的东西。 这有可能使得所构建的邮件头部变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">To: hardcoded@example.com</span><br><span class="line">Subject: hello</span><br><span class="line">cc: spamvictim@example.com</span><br></pre></td></tr></table></figure>

<p>就像SQL注入那样，如果我们信任了用户提供的主题行，那样同样也会允许他构建一个头部恶意集，他也就能够利用联系人表单来发送垃圾邮件。</p>
<p><strong>解决方案</strong></p>
<p>我们能够采用与阻止SQL注入相同的方式来阻止这种攻击： 总是校验或者转义用户提交的内容。</p>
<p>Django内建邮件功能（在 <code>django.core.mail</code> 中）根本不允许在用来构建邮件头部的字段中存在换行符（表单，收件地址，还有主题）。 如果您试图使用 <code>django.core.mail.send_mail</code> 来处理包含换行符的主题时，Django将会抛出BadHeaderError异常。</p>
<p>如果你没有使用Django内建邮件功能来发送邮件，那么你需要确保包含在邮件头部的换行符能够引发错误或者被去掉。 你或许想仔细阅读 <code>django.core.mail</code> 中的 <code>SateMIMEText</code> 类来看看Django是如何做到这一点的。</p>
<h3 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h3><p><em>目录遍历</em> ：是另外一种注入方式的攻击，在这种攻击中，恶意用户诱骗文件系统代码对Web服务器不应该访问的文件进行读取和/或写入操作。</p>
<p>例子可以是这样的，某个视图试图在没有仔细对文件进行防毒处理的情况下从磁盘上读取文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def dump_file(request):</span><br><span class="line">    filename &#x3D; request.GET[&quot;filename&quot;]</span><br><span class="line">    filename &#x3D; os.path.join(BASE_PATH, filename)</span><br><span class="line">    content &#x3D; open(filename).read()</span><br><span class="line"></span><br><span class="line">    # ...</span><br></pre></td></tr></table></figure>

<p>尽管一眼看上去，视图通过 <code>BASE_PATH</code> （通过使用 <code>os.path.join</code> ）限制了对于文件的访问，但如果攻击者使用了包含 <code>..</code> （两个句号，父目录的一种简写形式）的文件名，她就能够访问到 <code>BASE_PATH</code> 目录结构以上的文件。对她来说，发现究竟使用几个点号只是时间问题，比如这样：<code>../../../../../etc/passwd</code>。</p>
<p>任何不做适当转义地读取文件操作，都可能导致这样的问题。 允许 <em>写</em> 操作的视图同样容易发生问题，而且结果往往更加可怕。</p>
<p>这个问题的另一种表现形式，出现在根据URL和其他的请求信息动态地加载模块。 一个众所周知的例子来自于Ruby on Rails。 在2006年上半年之前，Rails使用类似于 <code>http://example.com/person/poke/1</code> 这样的URL直接加载模块和调用函数。 结果是，精心构造的URL，可以自动地调用任意的代码，包括数据库的清空脚本。</p>
<p><strong>解决方案</strong></p>
<p>如果你的代码需要根据用户的输入来读写文件，你就需要确保，攻击者不能访问你所禁止访问的目录。</p>
<h3 id="暴露错误消息"><a href="#暴露错误消息" class="headerlink" title="暴露错误消息"></a>暴露错误消息</h3><p>在开发过程中，通过浏览器检查错误和跟踪异常是非常有用的。 Django提供了漂亮且详细的debug信息，使得调试过程更加容易。</p>
<p>然而，一旦在站点上线以后，这些消息仍然被显示，它们就可能暴露你的代码或者是配置文件内容给攻击者。</p>
<p>还有，错误和调试消息对于最终用户而言是毫无用处的。 Django的理念是，站点的访问者永远不应该看到与应用相关的出错消息。 如果你的代码抛出了一个没有处理的异常，网站访问者不应该看到调试信息或者 <em>任何</em> 代码片段或者Python（面向开发者）出错消息。 访问者应该只看到友好的无法访问的页面。</p>
<p>当然，开发者需要在debug时看到调试信息。 因此，框架就要将这些出错消息显示给受信任的网站开发者，而要向公众隐藏。</p>
<p><strong>解决方案</strong></p>
<p>正如我们在第12章所提到的，Django的<code>DEBUG</code> 设置控制这些错误信息的显示。 当你准备部署时请确认把这个设置为：<code>False</code> 。</p>
<p>在Apache和mod_python下开发的人员，还要保证在Apache的配置文件中关闭 <code>PythonDebug Off</code> 选项，这个会在Django被加载以前去除出错消息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/17/django-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/" data-id="ckacfykqg001hpzi00m5c6xqz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-django-sql注入" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/17/django-sql%E6%B3%A8%E5%85%A5/" class="article-date">
  <time datetime="2020-05-17T13:26:03.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/17/django-sql%E6%B3%A8%E5%85%A5/">django sql注入</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令</p>
<p>利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句</p>
<ol>
<li><p>永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双’-‘进行转换等。</p>
</li>
<li><p>永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。</p>
</li>
<li><p>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</p>
</li>
<li><p>不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。</p>
</li>
<li><p>应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装。</p>
</li>
</ol>
<p><strong>利用Dajngo的ORM可有效避免sql注入，因为Django已经对特殊字符进行转义</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/17/django-sql%E6%B3%A8%E5%85%A5/" data-id="ckacfykov0000pzi06fqp493d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-如何设计良好API" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/17/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E8%89%AF%E5%A5%BDAPI/" class="article-date">
  <time datetime="2020-05-17T12:44:13.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/17/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E8%89%AF%E5%A5%BDAPI/">如何设计良好API</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="职责清晰"><a href="#职责清晰" class="headerlink" title="职责清晰"></a>职责清晰</h3><p>API 必须指明接口类型，接口职责，具体解决什么业务</p>
<h3 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h3><p>职责清晰之后，尽量做到接口职责单一</p>
<h3 id="协议规范"><a href="#协议规范" class="headerlink" title="协议规范"></a>协议规范</h3><p>明确接口协议，http，https，ftp等等，或者其他rpc协议</p>
<h3 id="路径规则，合理命名"><a href="#路径规则，合理命名" class="headerlink" title="路径规则，合理命名"></a>路径规则，合理命名</h3><p>网址尽量用名词而不是动词</p>
<p>/api/v1.0/Pruduct/2020</p>
<p>/api/v1.0/Users/2020</p>
<p>其次，命名需要注意这些：</p>
<ul>
<li>尽可能和领域名词保持一致，例如聚合根、实体、事件等</li>
<li>RESTful 设计的 URI 中使用名词复数</li>
<li>尽可能不要过度简写，例如将 <code>user</code> 简写成 <code>usr</code></li>
<li>尽可能使用不需要编码的字符</li>
</ul>
<h3 id="http请求方式"><a href="#http请求方式" class="headerlink" title="http请求方式"></a>http请求方式</h3><p>restful </p>
<p>接口基本访问协议：get(获取)，post(新增)，put(修改)和delete(删除)</p>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>域名分为主域名和专有域名，主域名适合api长期不变或变化较少的业务，专有域名是解决具体的专有业务的</p>
<h3 id="跨域考虑"><a href="#跨域考虑" class="headerlink" title="跨域考虑"></a>跨域考虑</h3><p>在明确域名的情况下，一定要考虑接口是否跨域，以及跨域应采用的技术手段等</p>
<h3 id="版本设计"><a href="#版本设计" class="headerlink" title="版本设计"></a>版本设计</h3><p>对于接口的url，应加版本号<a href="http://api.demo.com/v{d}/，如" target="_blank" rel="noopener">http://api.demo.com/v{d}/，如</a> ，其中d表示版本号,如v1.0,v2.0</p>
<p>例子：获取产品号为2019,版本号为v1.0的版本号的产品信息</p>
<h3 id="适度过滤信息"><a href="#适度过滤信息" class="headerlink" title="适度过滤信息"></a>适度过滤信息</h3><p>当记录数比较多时(如 SELECT * FROM TBName)，因适当添加一些条件对数据进行过滤，如TOP,分页,分组，排序和WHERE条件等</p>
<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>返回数据格式，一般包括三个字段：</p>
<p>(1) 失败情况（状态码、错误码和错误描述）</p>
<p>(2) 成功情况（标识id,数据对象,状态码）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;id&quot;: &quot;dsafrgrg&quot;,</span><br><span class="line">&quot;users&quot;: &#123;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">&quot;status&quot;:1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安全性原则"><a href="#安全性原则" class="headerlink" title="安全性原则"></a>安全性原则</h3><p>接口暴露的考虑，接口并发量的考虑，接口防攻击的考虑，接口跨域的考虑等。</p>
<p>针对错误的调用方式，API 不应该进入业务处理流程，及时给出错误信息；对于接口滥用的情况，需要做一些限速的方案；对于一些浏览器消费者的问题，可以在让 API 返回一些安全增强头部，例如：X-XSS-Protection、Content-Security-Policy 等。</p>
<h3 id="接口可扩展"><a href="#接口可扩展" class="headerlink" title="接口可扩展"></a>接口可扩展</h3><p>在设计接口时，充分考虑接口的可扩展性。</p>
<h3 id="API-权限"><a href="#API-权限" class="headerlink" title="API 权限"></a>API 权限</h3><p>任何api，从权限上，可归结为匿名api和非匿名api，前者不需要验证，后者需要验证。</p>
<h3 id="定义api返回码"><a href="#定义api返回码" class="headerlink" title="定义api返回码"></a>定义api返回码</h3><p>在api设计时，要定好api返回码，如：</p>
<p>1 –授权过期</p>
<p>404–未找到资源</p>
<p>500–内部服务器错误</p>
<p>600–账号被锁</p>
<h3 id="API-设计评审清单"><a href="#API-设计评审清单" class="headerlink" title="API 设计评审清单"></a>API 设计评审清单</h3><ul>
<li>URI 命名是否通过聚合根和实体统一</li>
<li>URI 命名是否采用名词复数和连接线</li>
<li>URI 命名是否都是单词小写</li>
<li>URI 是否暴露了不必要的信息，例如 <code>/cgi-bin</code></li>
<li>URI 规则是否统一</li>
<li>资源提供的能力是否彼此独立</li>
<li>URI 是否存在需要编码的字符</li>
<li>请求和返回的参数是否不多不少</li>
<li>资源的 ID 参数是否通过 PATH 参数传递</li>
<li>认证和授权信息是否暴露到 query 参数中</li>
<li>参数是否使用奇怪的缩写</li>
<li>参数和响应数据中的字段命名统一</li>
<li>是否存在无意义的对象包装 例如 <code>{&quot;data&quot;:{}&#39;}</code></li>
<li>出错时是否破坏约定的数据结构</li>
<li>是否使用合适的状态码</li>
<li>是否使用合适的媒体类型</li>
<li>响应数据的单复是否和数据内容一致</li>
<li>响应头中是否有缓存信息</li>
<li>是否进行了版本管理</li>
<li>版本信息是否作为 URI 的前缀存在</li>
<li>是否提供 API 服务期限</li>
<li>是否提供了 API 返回所有 API 的索引</li>
<li>是否进行了认证和授权</li>
<li>是否采用 HTTPS</li>
<li>是否检查了非法参数</li>
<li>是否增加安全性的头部</li>
<li>是否有限流策略</li>
<li>是否支持 CORS</li>
<li>响应中的时间格式是否采用 <code>ISO 8601</code> 标准</li>
<li>是否存在越权访问</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/17/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E8%89%AF%E5%A5%BDAPI/" data-id="ckacfykpm000rpzi0fehnfwon" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/web/" rel="tag">web</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python-interview" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/17/python-interview/" class="article-date">
  <time datetime="2020-05-17T04:26:13.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/17/python-interview/">python interview</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/17/python-interview/" data-id="ckacfykpg000fpzi00vl7cjch" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-faust-demo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/16/faust-demo/" class="article-date">
  <time datetime="2020-05-16T14:38:21.000Z" itemprop="datePublished">2020-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/16/faust-demo/">faust demo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/16/faust-demo/" data-id="ckacfykp70004pzi0785x0oab" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/python-kafka/" rel="tag">python kafka</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kill-9" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/16/kill-9/" class="article-date">
  <time datetime="2020-05-16T13:55:00.000Z" itemprop="datePublished">2020-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/16/kill-9/">kill -9</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="kill-命令"><a href="#kill-命令" class="headerlink" title="kill 命令"></a><strong>kill 命令</strong></h2><p>在Linux中终止一个进程有两种方式，如果是前台进程可以使用Ctrl+C键进行终止；如果是后台进程，那么需要使用kill命令来终止。（其实Ctrl+C也是kill命令）</p>
<p>kill命令的格式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kill[参数][进程号]</span><br><span class="line">如：</span><br><span class="line">kill 21121</span><br><span class="line">kill -9 21121</span><br></pre></td></tr></table></figure>

<p>其中[参数]是可选的，进程号可以通过jps/ps/pidof/pstree/top等工具获取。</p>
<p>kill的命令参数有以下几种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-l 信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称</span><br><span class="line"></span><br><span class="line">-a 当处理当前进程时，不限制命令名和进程号的对应关系</span><br><span class="line"></span><br><span class="line">-p 指定kill 命令只打印相关进程的进程号，而不发送任何信号</span><br><span class="line"></span><br><span class="line">-s 指定发送信号</span><br><span class="line"></span><br><span class="line">-u 指定用户</span><br></pre></td></tr></table></figure>

<p>通常情况下，我们使用的-l(信号)的时候比较多，如我们前文提到的kill -9中的9就是信号。</p>
<p>信号如果没有指定的话，默认会发出终止信号(15)。常用的信号如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HUP 1 终端断线</span><br><span class="line"></span><br><span class="line">INT 2 中断（同 Ctrl + C）</span><br><span class="line"></span><br><span class="line">QUIT 3 退出（同 Ctrl + \）</span><br><span class="line"></span><br><span class="line">TERM 15 终止</span><br><span class="line"></span><br><span class="line">KILL 9 强制终止</span><br><span class="line"></span><br><span class="line">CONT 18 继续（与STOP相反， fg&#x2F;bg命令）</span><br><span class="line"></span><br><span class="line">STOP 19 暂停（同 Ctrl + Z）</span><br></pre></td></tr></table></figure>

<p>比较常用的就是强制终止信号：9和终止信号：15，另外，中断信号：2其实就是我们前文提到的Ctrl + C结束前台进程。</p>
<p>那么，kill -9 和 kill -15到底有什么区别呢？该如何选择呢？</p>
<h2 id="kill-9-和-kill-15的区别"><a href="#kill-9-和-kill-15的区别" class="headerlink" title="kill -9 和 kill -15的区别"></a><strong>kill -9 和 kill -15的区别</strong></h2><p>kill命令默认的信号就是15，首先来说一下这个默认的kill -15信号。</p>
<p>当使用kill -15时，系统会发送一个SIGTERM的信号给对应的程序。当程序接收到该信号后，具体要如何处理是自己可以决定的。</p>
<p>这时候，应用程序可以选择：</p>
<p>1、立即停止程序2、释放响应资源后停止程序3、忽略该信号，继续执行程序</p>
<p>因为kill -15信号只是通知对应的进程要进行”安全、干净的退出”，程序接到信号之后，退出前一般会进行一些”准备工作”，如资源释放、临时文件清理等等，如果准备工作做完了，再进行程序的终止。</p>
<p>但是，如果在”准备工作”进行过程中，遇到阻塞或者其他问题导致无法成功，那么应用程序可以选择忽略该终止信号。</p>
<p>这也就是为什么我们有的时候使用kill命令是没办法”杀死”应用的原因，<strong>因为默认的kill信号是SIGTERM（15），而SIGTERM（15）的信号是可以被阻塞和忽略的。</strong></p>
<p>和kill -15相比，kill -9就相对强硬一点，系统会发出SIGKILL信号，他要求接收到该信号的程序应该立即结束运行，不能被阻塞或者忽略。</p>
<p>所以，<strong>相比于kill -15命令，kill -9在执行时，应用程序是没有时间进行”准备工作”的，所以这通常会带来一些副作用，数据丢失或者终端无法恢复到正常状态等</strong></p>
<p><strong>重点：非必要不要执行 kill -9 命令</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/16/kill-9/" data-id="ckacfykpb0008pzi0co2kcsl9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kafka-base" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/16/kafka-base/" class="article-date">
  <time datetime="2020-05-16T12:50:44.000Z" itemprop="datePublished">2020-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/16/kafka-base/">kafka base</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>前言</p>
</li>
<li><p>一、Kafka基础</p>
</li>
<li><ul>
<li>消息系统的作用</li>
<li>1.Topic 主题</li>
<li>2.Partition 分区</li>
<li>3.Producer - 生产者</li>
<li>4.Consumer - 消费者</li>
<li>5.Message - 消息</li>
</ul>
</li>
<li><p>二、kafka的集群架构</p>
</li>
<li><ul>
<li>Replica - 副本</li>
<li>Consumer Group - 消费者组</li>
<li>Controller</li>
<li>kafka和zookeeper如何配合工作</li>
</ul>
</li>
<li><p>加餐时间</p>
</li>
<li><ul>
<li>1.Kafka性能好在什么地方？</li>
<li>2.日志分段存储</li>
<li>3.Kafka的网络设计</li>
<li></li>
</ul>
</li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>应大部分的小伙伴的要求，在Yarn之前先来一个kafka的小插曲，轻松愉快。</p>
<h2 id="一、Kafka基础"><a href="#一、Kafka基础" class="headerlink" title="一、Kafka基础"></a>一、Kafka基础</h2><h2 id="消息系统的作用"><a href="#消息系统的作用" class="headerlink" title="消息系统的作用"></a>消息系统的作用</h2><p>引入一个场景，我们知道中国移动，中国联通，中国电信的日志处理，是交给外包去做大数据分析的，假设现在它们的日志都交给了你做的系统去做用户画像分析。</p>
<p><img src="2020/05/16/kafka-base/kafka1.png" alt="img"></p>
<p>按照刚刚前面提到的消息系统的作用，我们知道了消息系统其实就是一个<strong>模拟缓存</strong> ，且<strong>仅仅是起到了缓存的作用</strong> 而并不是真正的缓存，数据仍然是存储在磁盘上面而不是内存。</p>
<h2 id="1-Topic-主题"><a href="#1-Topic-主题" class="headerlink" title="1.Topic 主题"></a>1.Topic 主题</h2><p>kafka学习了数据库里面的设计，在里面设计了topic（主题），这个东西类似于关系型数据库的表</p>
<p><img src="https://pic2.zhimg.com/80/v2-32846cde6385e104150543c2bd33e255_720w.jpg" alt="img"></p>
<p>此时我需要获取中国移动的数据，那就直接监听TopicA即可</p>
<h2 id="2-Partition-分区"><a href="#2-Partition-分区" class="headerlink" title="2.Partition 分区"></a>2.Partition 分区</h2><p>kafka还有一个概念叫Partition（分区），分区具体在服务器上面表现起初就是一个目录，一个主题下面有多个分区，这些分区会存储到不同的服务器上面，或者说，其实就是在不同的主机上建了不同的目录。这些分区主要的信息就存在了.log文件里面。跟数据库里面的分区差不多，是为了提高性能。</p>
<p><img src="https://pic4.zhimg.com/80/v2-af7ed1fd8fb43ea93baa9d2db2c4e5c3_720w.jpg" alt="img"></p>
<p>至于为什么提高了性能，很简单，多个分区多个线程，多个线程并行处理肯定会比单线程好得多</p>
<p>Topic和partition像是HBASE里的table和region的概念，table只是一个逻辑上的概念，真正存储数据的是region，这些region会分布式地存储在各个服务器上面，对应于kafka，也是一样，<strong>Topic也是逻辑概念</strong> ，而partition就是分布式存储单元。这个设计是保证了海量数据处理的基础。我们可以对比一下，如果HDFS没有block的设计，一个100T的文件也只能单独放在一个服务器上面，那就直接占满整个服务器了，引入block后，大文件可以分散存储在不同的服务器上。</p>
<p>注意：1.分区会有单点故障问题，所以我们会为每个分区设置副本数</p>
<p>2.分区的编号是从0开始的</p>
<h2 id="3-Producer-生产者"><a href="#3-Producer-生产者" class="headerlink" title="3.Producer - 生产者"></a>3.Producer - 生产者</h2><p>往消息系统里面发送数据的就是生产者</p>
<p><img src="https://pic4.zhimg.com/80/v2-3acb2d8ff2a4672d66ed93f23dfe222b_720w.jpg" alt="img"></p>
<h2 id="4-Consumer-消费者"><a href="#4-Consumer-消费者" class="headerlink" title="4.Consumer - 消费者"></a>4.Consumer - 消费者</h2><p>从kafka里读取数据的就是消费者</p>
<p><img src="https://pic3.zhimg.com/80/v2-18604049cbfc5da50c33ea20b241456e_720w.jpg" alt="img"></p>
<h2 id="5-Message-消息"><a href="#5-Message-消息" class="headerlink" title="5.Message - 消息"></a>5.Message - 消息</h2><p>kafka里面的我们处理的数据叫做消息</p>
<h2 id="二、kafka的集群架构"><a href="#二、kafka的集群架构" class="headerlink" title="二、kafka的集群架构"></a>二、kafka的集群架构</h2><p>创建一个TopicA的主题，3个分区分别存储在不同的服务器，也就是broker下面。<strong>Topic是一个逻辑上的概念</strong> ，并不能直接在图中把Topic的相关单元画出</p>
<p><img src="https://pic2.zhimg.com/80/v2-34ac636c297dd20ec43e992bdf034d01_720w.jpg" alt="img"></p>
<p><strong>需要注意：kafka在0.8版本以前是没有副本机制的，所以在面对服务器宕机的突发情况时会丢失数据，所以尽量避免使用这个版本之前的kafka</strong></p>
<h2 id="Replica-副本"><a href="#Replica-副本" class="headerlink" title="Replica - 副本"></a>Replica - 副本</h2><p>kafka中的partition为了保证数据安全，所以每个partition可以设置多个副本。</p>
<p>此时我们对分区0,1,2分别设置3个副本（其实设置两个副本是比较合适的）</p>
<p><img src="https://pic3.zhimg.com/80/v2-98e71e20de54e547a02a9fd38360ec16_720w.jpg" alt="img"></p>
<p>而且其实每个副本都是有角色之分的，它们会选取一个副本作为leader，而其余的作为follower，我们的<strong>生产者在发送数据的时候，是直接发送到leader partition里面</strong> ，然后follower partition会去leader那里自行同步数据，<strong>消费者消费数据的时候，也是从leader那去消费数据的</strong> 。</p>
<p><img src="https://pic1.zhimg.com/80/v2-25f67642f98939529165464e08d8c334_720w.jpg" alt="img"></p>
<h2 id="Consumer-Group-消费者组"><a href="#Consumer-Group-消费者组" class="headerlink" title="Consumer Group - 消费者组"></a>Consumer Group - 消费者组</h2><p>我们在消费数据时会在代码里面指定一个group.id,这个id代表的是消费组的名字，而且<strong>这个group.id就算不设置，系统也会默认设置</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conf.setProperty(&quot;group.id&quot;,&quot;tellYourDream&quot;)</span><br></pre></td></tr></table></figure>

<p>我们所熟知的一些消息系统一般来说会这样设计，就是只要有一个消费者去消费了消息系统里面的数据，那么其余所有的消费者都不能再去消费这个数据。可是kafka并不是这样,比如现在consumerA去消费了一个topicA里面的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumerA:    group.id &#x3D; aconsumerB:    group.id &#x3D; aconsumerC:    group.id &#x3D; bconsumerD:    group.id &#x3D; b</span><br></pre></td></tr></table></figure>

<p>再让consumerB也去消费TopicA的数据，它是消费不到了，但是我们在consumerC中重新指定一个另外的group.id，consumerC是可以消费到topicA的数据的。而consumerD也是消费不到的，所以在kafka中，<strong>不同组可有唯一的一个消费者去消费同一主题的数据</strong> 。</p>
<p>所以消费者组就是让多个消费者并行消费信息而存在的，而且它们不会消费到同一个消息，如下，consumerA，B，C是不会互相干扰的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer group:a    consumerA    consumerB    consumerC</span><br></pre></td></tr></table></figure>



<p><img src="https://pic2.zhimg.com/80/v2-90497c2375653342dc59458dc7543ff9_720w.jpg" alt="img"></p>
<p>如图，因为前面提到过了消费者会直接和leader建立联系，所以它们分别消费了三个leader，所以<strong>一个分区不会让消费者组里面的多个消费者去消费</strong> ，但是在消费者不饱和的情况下，<strong>一个消费者是可以去消费多个分区的数据的</strong> 。</p>
<h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>熟知一个规律：在大数据分布式文件系统里面，95%的都是主从式的架构，个别是对等式的架构，比如ElasticSearch。</p>
<p>kafka也是主从式的架构，主节点就叫controller，其余的为从节点，controller是需要和zookeeper进行配合管理整个kafka集群。</p>
<h2 id="kafka和zookeeper如何配合工作"><a href="#kafka和zookeeper如何配合工作" class="headerlink" title="kafka和zookeeper如何配合工作"></a>kafka和zookeeper如何配合工作</h2><p>kafka严重依赖于zookeeper集群（所以之前的zookeeper文章还是有点用的）。所有的broker在启动的时候都会往zookeeper进行注册，目的就是选举出一个controller，这个选举过程非常简单粗暴，就是一个谁先谁当的过程，不涉及什么算法问题。</p>
<p>那成为controller之后要做啥呢，它会监听zookeeper里面的多个目录，例如有一个目录/brokers/，其他从节点往这个目录上<strong>注册（就是往这个目录上创建属于自己的子目录而已）</strong> 自己，这时命名规则一般是它们的id编号，比如/brokers/0,1,2</p>
<p>注册时各个节点必定会暴露自己的主机名，端口号等等的信息，此时controller就要去<strong>读取注册上来的从节点的数据（通过监听机制），生成集群的元数据信息，之后把这些信息都分发给其他的服务器，让其他服务器能感知到集群中其它成员的存在</strong> 。</p>
<p>此时模拟一个场景，我们创建一个主题（其实就是在zookeeper上/topics/topicA这样创建一个目录而已），kafka会把分区方案生成在这个目录中，此时controller就监听到了这一改变，它会去同步这个目录的元信息，然后同样下放给它的从节点，通过这个方法让整个集群都得知这个分区方案，此时从节点就各自创建好目录等待创建分区副本即可。这也是整个集群的管理机制。</p>
<h2 id="加餐时间"><a href="#加餐时间" class="headerlink" title="加餐时间"></a>加餐时间</h2><h2 id="1-Kafka性能好在什么地方？"><a href="#1-Kafka性能好在什么地方？" class="headerlink" title="1.Kafka性能好在什么地方？"></a>1.Kafka性能好在什么地方？</h2><h3 id="①-顺序写"><a href="#①-顺序写" class="headerlink" title="① 顺序写"></a>① 顺序写</h3><p>操作系统每次从磁盘读写数据的时候，需要先寻址，也就是先要找到数据在磁盘上的物理位置，然后再进行数据读写，如果是机械硬盘，寻址就需要较长的时间。kafka的设计中，数据其实是存储在磁盘上面，一般来说，会把数据存储在内存上面性能才会好。但是kafka用的是顺序写，追加数据是追加到末尾，磁盘顺序写的性能极高，在磁盘个数一定，转数达到一定的情况下，基本和内存速度一致</p>
<p>随机写的话是在文件的某个位置修改数据，性能会较低。</p>
<h3 id="②-零拷贝"><a href="#②-零拷贝" class="headerlink" title="② 零拷贝"></a>② 零拷贝</h3><p>先来看看非零拷贝的情况</p>
<p><img src="https://pic2.zhimg.com/80/v2-ee7a1f19ae166325d0251f32bc7a49c9_720w.jpg" alt="img"></p>
<p>可以看到数据的拷贝从内存拷贝到kafka服务进程那块，又拷贝到socket缓存那块，整个过程耗费的时间比较高，kafka利用了Linux的sendFile技术（NIO），省去了进程切换和一次数据拷贝，让性能变得更好。</p>
<p><img src="https://pic3.zhimg.com/80/v2-a16b6969abf868b330fbfb8901f1746a_720w.jpg" alt="img"></p>
<h2 id="2-日志分段存储"><a href="#2-日志分段存储" class="headerlink" title="2.日志分段存储"></a>2.日志分段存储</h2><p>Kafka规定了一个分区内的.log文件最大为1G，做这个限制目的是为了方便把.log加载到内存去操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000000000000000.index00000000000000000000.log00000000000000000000.timeindex00000000000005367851.index00000000000005367851.log00000000000005367851.timeindex00000000000009936472.index00000000000009936472.log00000000000009936472.timeindex</span><br></pre></td></tr></table></figure>

<p>这个9936472之类的数字，就是代表了这个日志段文件里包含的起始offset，也就说明这个分区里至少都写入了接近1000万条数据了。Kafka broker有一个参数，log.segment.bytes，限定了每个日志段文件的大小，最大就是1GB，一个日志段文件满了，就自动开一个新的日志段文件来写入，避免单个文件过大，影响文件的读写性能，这个过程叫做log rolling，正在被写入的那个日志段文件，叫做active log segment。</p>
<p>如果大家有看前面的两篇有关于HDFS的文章时，就会发现NameNode的edits log也会做出限制，所以这些框架都是会考虑到这些问题。</p>
<h2 id="3-Kafka的网络设计"><a href="#3-Kafka的网络设计" class="headerlink" title="3.Kafka的网络设计"></a>3.Kafka的网络设计</h2><p>kafka的网络设计和Kafka的调优有关，这也是为什么它能支持高并发的原因</p>
<p><img src="https://pic2.zhimg.com/80/v2-ff67587f49d58e9d78a4185a54570ded_720w.jpg" alt="img"></p>
<p>首先客户端发送请求全部会先发送给一个Acceptor，broker里面会存在3个线程（默认是3个），这3个线程都是叫做processor，Acceptor不会对客户端的请求做任何的处理，直接封装成一个个socketChannel发送给这些processor形成一个队列，发送的方式是轮询，就是先给第一个processor发送，然后再给第二个，第三个，然后又回到第一个。消费者线程去消费这些socketChannel时，会获取一个个request请求，这些request请求中就会伴随着数据。</p>
<p>线程池里面默认有8个线程，这些线程是用来处理request的，解析请求，如果request是写请求，就写到磁盘里。读的话返回结果。processor会从response中读取响应数据，然后再返回给客户端。这就是Kafka的网络三层架构。</p>
<p>所以如果我们需要对kafka进行增强调优，增加processor并增加线程池里面的处理线程，就可以达到效果。request和response那一块部分其实就是起到了一个缓存的效果，是考虑到processor们生成请求太快，线程数不够不能及时处理的问题。</p>
<p>所以这就是一个加强版的reactor网络线程模型。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/16/kafka-base/" data-id="ckacfykqi001ipzi0da7xc4gx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/kafka/" rel="tag">kafka</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kafka-基础概念" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/15/kafka-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2020-05-15T12:24:17.000Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/15/kafka-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">kafka 基础概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/15/kafka-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" data-id="ckacfykpe000cpzi0eucm549q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kafka-单击测试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/15/kafka-%E5%8D%95%E5%87%BB%E6%B5%8B%E8%AF%95/" class="article-date">
  <time datetime="2020-05-15T11:36:39.000Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/15/kafka-%E5%8D%95%E5%87%BB%E6%B5%8B%E8%AF%95/">kafka 单机测试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="如下教程用来本地测试kafka流式数据处理功能"><a href="#如下教程用来本地测试kafka流式数据处理功能" class="headerlink" title="如下教程用来本地测试kafka流式数据处理功能"></a>如下教程用来本地测试kafka流式数据处理功能</h2><h3 id="zookeeper-安装"><a href="#zookeeper-安装" class="headerlink" title="zookeeper 安装"></a>zookeeper 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull wurstmeister&#x2F;zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="zookeeper启动"><a href="#zookeeper启动" class="headerlink" title="zookeeper启动"></a>zookeeper启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name zookeeper -p 2181 -t wurstmeister&#x2F;zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="kafka-安装"><a href="#kafka-安装" class="headerlink" title="kafka 安装"></a>kafka 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull wurstmeister&#x2F;kafka</span><br><span class="line">sudo docker run -d --name kafka --publish 9092:9092 \</span><br><span class="line">--link zookeeper \</span><br><span class="line">--env KAFKA_ZOOKEEPER_CONNECT&#x3D;zookeeper:2181 \</span><br><span class="line">--env KAFKA_ADVERTISED_HOST_NAME&#x3D;127.0.0.1 \</span><br><span class="line">--env KAFKA_ADVERTISED_PORT&#x3D;9092 --restart&#x3D;always \</span><br><span class="line">--volume &#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime \</span><br><span class="line">wurstmeister&#x2F;kafka</span><br></pre></td></tr></table></figure>

<h3 id="测试发送消息"><a href="#测试发送消息" class="headerlink" title="测试发送消息"></a>测试发送消息</h3><p>kafka内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -i -t $&#123;CONTAINER ID&#125; sh </span><br><span class="line">cd opt&#x2F;kafka_2.12-2.1.0</span><br><span class="line">创建主题</span><br><span class="line">bin&#x2F;kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 --partitions 1 --topic mykafka</span><br><span class="line">创建生产者</span><br><span class="line">bin&#x2F;kafka-console-producer.sh --broker-list localhost:9092 --topic mykafka</span><br><span class="line"></span><br><span class="line">新tty</span><br><span class="line">创建消费者</span><br><span class="line">bin&#x2F;kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic mykafka --from-beginning</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/15/kafka-%E5%8D%95%E5%87%BB%E6%B5%8B%E8%AF%95/" data-id="ckacfykpc0009pzi0cny2159z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-uwsgi-gunicorn-区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/10/uwsgi-gunicorn-%E5%8C%BA%E5%88%AB/" class="article-date">
  <time datetime="2020-05-10T14:29:55.000Z" itemprop="datePublished">2020-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/10/uwsgi-gunicorn-%E5%8C%BA%E5%88%AB/">uwsgi gunicorn 区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://zhu327.github.io/2018/08/29/gunicorn与uwsgi之我见/" target="_blank" rel="noopener">https://zhu327.github.io/2018/08/29/gunicorn%E4%B8%8Euwsgi%E4%B9%8B%E6%88%91%E8%A7%81/</a></p>
<p><a href="https://blog.csdn.net/shudaqi2010/article/details/71172683" target="_blank" rel="noopener">https://blog.csdn.net/shudaqi2010/article/details/71172683</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hackerman-ops.github.io/blog/2020/05/10/uwsgi-gunicorn-%E5%8C%BA%E5%88%AB/" data-id="ckacfykpn000spzi0b7d2et2l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="page-number" href="/blog/page/3/">3</a><a class="extend next" rel="next" href="/blog/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Django/" rel="tag">Django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/kafka/" rel="tag">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/process/" rel="tag">process</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/python-kafka/" rel="tag">python kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/web/" rel="tag">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/Django/" style="font-size: 10px;">Django</a> <a href="/blog/tags/kafka/" style="font-size: 10px;">kafka</a> <a href="/blog/tags/linux/" style="font-size: 16.67px;">linux</a> <a href="/blog/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/blog/tags/process/" style="font-size: 10px;">process</a> <a href="/blog/tags/python/" style="font-size: 20px;">python</a> <a href="/blog/tags/python-kafka/" style="font-size: 10px;">python kafka</a> <a href="/blog/tags/redis/" style="font-size: 10px;">redis</a> <a href="/blog/tags/web/" style="font-size: 10px;">web</a> <a href="/blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 16.67px;">中间件</a> <a href="/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.33px;">数据结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2020/05/17/django-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/">django 安全编码问题</a>
          </li>
        
          <li>
            <a href="/blog/2020/05/17/django-sql%E6%B3%A8%E5%85%A5/">django sql注入</a>
          </li>
        
          <li>
            <a href="/blog/2020/05/17/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E8%89%AF%E5%A5%BDAPI/">如何设计良好API</a>
          </li>
        
          <li>
            <a href="/blog/2020/05/17/python-interview/">python interview</a>
          </li>
        
          <li>
            <a href="/blog/2020/05/16/faust-demo/">faust demo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 wuguobin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">

  
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>




<script src="/blog/js/script.js"></script>




  </div>
</body>
</html>